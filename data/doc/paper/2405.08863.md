# HepLean: Digitalising high energy physics 

Joseph Tooby-Smith<br>Department of Physics, LEPP, Cornell University, Ithaca, NY 14853, USA

May 16, 2024


#### Abstract

We introduce HepLean, an open-source project to digitalise definitions, theorems, proofs, and calculations in high energy physics using the interactive theorem prover Lean 4. HepLean has the potential to benefit the high energy physics community in four ways: making it easier to find existing results, allowing the creation of new results using artificial intelligence and automated methods, allowing easy review of papers for mathematical correctness, and providing new ways to teach high energy physics. We will discuss these in detail. We will also demonstrate the digitalisation of three areas of high energy physics in HepLean: Cabibbo-Kobayashi-Maskawa matrices in flavour physics, local anomaly cancellation, and Higgs physics.


Link to GitHub repository: https://github.com/HEPLean/HepLean.

## CONTENTS

1 Introduction ..... 2
1.1 Motivation ..... 4
2 CKM Matrices ..... 5
2.1 Definition ..... 5
2.2 Relations between elements ..... 5
2.3 Equivalence relation ..... 6
2.4 Invariants ..... 6
2.5 Standard parameterisation ..... 7
3 Anomaly cancellation ..... 8
3.1 Definitions ..... 9
3.2 Permutations among species ..... 10
3.3 Excluding the gravitational anomaly ..... 10
4 Higgs Physics ..... 11
4.1 Target vector space of the Higgs ..... 11
4.2 Minimising the potential ..... 11
4.3 The Higgs field ..... 12
4.4 Smoothness of the potential ..... 13
5 Future work ..... 14

## 1. INTRODUCTION

The aim of this paper is to introduce the reader to the GitHub hosted project HepLean. The purpose of HepLean is to digitalise results (meaning definitions, theorems, proofs, and calculations) from high energy physics in a way that computers can read them systematically, and check their correctness.

In HepLean, we carry out this digitalisation using the computer programming language Lean 4 (simply 'Lean' from hereon) [1]. Lean is a special type of computer language called an interactive theorem prover. It allows you to write down definitions and theorems using its mathematical foundation called 'dependent type theory'. Lean also allows you to give proofs of theorems using dependent type theory, and will certify if a proof is correct or not.

Results in high energy physics aren't typically, if ever, written using dependent type theory (at least explicitly). So at this point the reader may be wondering if it is possible to digitalise any result from high energy physics into Lean. The reason it is possible, is that the mathematicians and computer scientists have done most of the ground-work for us in the project MathLib [2].

MathLib is an ongoing project written in Lean to digitalise results in mathematics. It includes, for example, results from representation theory, the theory of smooth manifolds, topology, category theory etc., all built up from the foundations of dependent type theory. In Lean, you can use any theorem already proved, or any definition already made, in the proofs of new theorems and the making of new definitions. Thus, to write results from high energy physics in Lean, we can use the corpus of results in MathLib to help. One does not need to work with dependent type theory explicitly. Therefore, with MathLib at hand, the task of making definitions, proving theorems, or performing calculations (which can be reframed as theorems) in Lean, becomes much closer to what high energy physicists are familiar with. It is this work of the mathematicians and computer scientists which mean it is possible to digitalise results from high energy physics into Lean.

Using examples, we now give the reader a brief taste of what Lean code looks like. The two key objects in Lean are definitions, and theorems (or equivalently lemmas). A definition has the following basic structure:

def name_of_object ( $\mathrm{p} 1$ : parameter1) ... : type_of_object := the_def_of_the_object

As an example, the definition of the fixed-point subset of a group action of $\mathrm{G}$ on a set $\alpha$ is written in MathLib (with some minor changes) as follows:

```
def fixedBy ( }\alpha:\mathrm{ Type) (g : G) : Set }\alpha:
    { | g - x = x }
```

A lemma or theorem has the basic structure:

```
theorem name_of_theorem (p1 : parameter1) ... (a1 : assumption1) ... :
    thing_to_be_proved := by
    proof
```

For example, the theorem 'under a group action, points fixed by the action of $g$ are also fixed by the action of $g^{-1}$, appears in MathLib as the following Lean code:

```
theorem fixedBy_inv (g : G) : fixedBy }\alpha\mp@subsup{\textrm{g}}{}{-1}=\mathrm{ fixedBy }\alpha\textrm{g}:=\mathrm{ by
    ext
    rw [mem_fixedBy, mem_fixedBy] -- curser at end of this line (see below)
    rw [inv_smul_eq_iff, eq_comm]
```

Throughout this paper we will see more examples of definitions and theorems as well as some minor variations thereon.

When talking about results in high energy physics we also refer to calculations, for which there is no specific structure in Lean. We get around this by storing the result of a calculation in Lean as the statement of a theorem, and the calculation itself as the proof of that theorem.

As you work through a proof of a theorem in Lean, you are presented with information summarising the current goal to be proved, and the assumptions and parameters one has available. Lean presents this information in a 'tactic state' which has the following basic structure:

```
p1 : parameter1
...
a1 : assumption1
`current_state_of_goal
```

As an example, the last-but-one code snippet gives a proof of a theorem ' $f i x e d B y \_i n v '$ ' For this theorem, when the computer curser is placed (in an appropriate code editor) where indicated, the tactic state shown is:

```
\alpha : Type u_1
G : Type u_2

```

![](https://cdn.mathpix.com/cropped/2024_06_04_ecb79c70f7188cdd55a7g-03.jpg?height=48&width=302&top_left_y=1581&top_left_x=266)

```

```

![](https://cdn.mathpix.com/cropped/2024_06_04_ecb79c70f7188cdd55a7g-03.jpg?height=55&width=414&top_left_y=1623&top_left_x=267)

```
g : G
x\dagger : }
\vdash \mathrm { g } ^ { - 1 } \cdot \mathrm { x } \dagger = \mathrm { x } \dagger \leftrightarrow \mathrm { g } \cdot \mathrm { x } \dagger = \mathrm { x } \dagger
```

The tactic state here tells us, for example, that we have a type $G$ which has an instance as a group, and that we have a multiplicative action of $G$ on the type $\alpha$.

Using previously proven theorems or automated proving tactics, one can change the current goal in the tactic state, or for example, add new parameters. To prove a theorem in Lean the current goal must be turned to True, or for example, a contradiction given among the inputted assumptions.

HepLean is not the first time Lean has been applied outside the ivory towers of the mathematicians. Notably, the paper [3] used Lean to digitalise results in absorption theory, thermodynamics, and kinematics. The authors of that paper proposed the idea of a library of results in Lean for all the sciences. HepLean is a step in that direction for high energy physics. Additionally, the package SciLean [4], aims to provide a framework for scientific computing in Lean, and allows, for example, simulations of the harmonic oscillator in Lean. There are also individuals, notably Winston Yin, working on digitalising into MathLib areas of mathematics of specific interest to physicists. Interactive theorem provers other than Lean, have also been used to digitalise specific results of science, for example [5] used the interactive theorem prover Coq to digitalise parts of special relativity.

### 1.1. MOTIVATION

It is perhaps unsurprising that the motivation for HepLean is very similar to that of MathLib. The latter has been well-documented (see e.g., the Quanta article [6]). HepLean is motivated by its potential to benefit the high energy physics community. Here we will discuss four ways it does this:

Finding results in the literature: As a field, we currently store results from high energy physics in academic papers. This is a non-linear storage method in that results related to the same subject are scattered across the literature. This is unlike, for example, the storage of information in a text-book which is linear. Non-linear storage makes looking-up information hard. No doubt some readers of this paper will have struggled in the past to find a calculation or theorem in the high energy physics literature. HepLean, following MathLib, stores information linearly, meaning all results relating to e.g., CKM matrices, are in the same place within the project. This, along with Lean-specific look-up tools such as 'loogle' [7], or the Lean command 'exact?', mean that HepLean would make it easier to find results across high energy physics.

Creating new results: HepLean can streamline the process of proving new theorems or doing calculations. On top of the ability to easily use results previously digitalised in HepLean, the mathematicians and computer scientists have developed some powerful automated proof tactics to help. These automated tactics are commands in Lean that automatically do part of a calculation or proof. Some of these are algorithmic. Two examples are simp which is similar to Simplify in Mathematica, and aesop which automatically searches for simple proofs. Others depend on artificial intelligence to fill in parts of or complete proofs, see e.g., [8]. The machine learning models these AIs are based on could be improved using the corpus of results from HepLean as training data.

Reviewing for mathematical correctness: HepLean can make it easier to review papers for mathematical correctness. As previously mentioned, Lean will check if a proof is correct or not (it will not 'compile' if it contains an invalid proof of a result). Thus, for results written in HepLean there is no question about whether they are mathematically correct or not. There cannot be, for example, a mathematical typo, or a factor of 2 missing or a minus sign error. This is unlike LaTeX, which will compile even with such errors. ${ }^{1}$ Putting results into HepLean thus eliminates the need for a human to review the paper for mathematical correctness and helps authors to be confident in the mathematical correctness of their own papers.

Pedagogy: HepLean will provide at least two new ways to teach high energy physics. The first way is through Lean games. These games work by getting the player to fill out a proof to a given theorem (which could be a calculation) and automatically checking if the given proof is correct or not. These games can be created using the Lean 4 Game code [9]. As an example in mathematics there is the 'Natural Numbers Game' [10] and the 'Set Theory Game' [11] among others. The second way is through the creation of Master projects digitalising areas of high energy physics into HepLean. Students can make their own contributions to the field whilst learning about an area of high energy physics, and getting instantaneous feedback through Lean on the correctness of their work. This approach has been used extensively in MathLib.

At the time of writing, HepLean has three areas of high energy physics in which some results have been digitalised. These are Cabibbo-Kobayashi-Maskawa (CKM) matrices in flavour physics, local anomaly cancellation, and Higgs physics. In the next three sections we will present these digitalisations. The aim will be the broad picture rather than the detail. These areas cover a range of mathematics[^0]common in high energy physics. In particular in $\S 2$ we will see complex analysis and equivalence relations. In $\S 3$ we will see linear algebra, and group and representation theory. Lastly, in $\S 4$ we will see differential geometry (smooth maps) and extrema of functions. This paper will conclude in $\S 5$ with a discussion of future work.

## 2. CKM MATRICES

A CKM matrix describes how quarks interact with the weak-force, and in particular govern flavourchanging weak interactions in particle physics.

In HepLean, several results relating to CKM matrices have been digitalised by the author. Primarily these are: the definition of a CKM matrix; relations between the elements of a CKM matrix; the equivalence relation on CKM matrices; invariants of CKM matrices; and, the standard parameterisation of a CKM matrix. We will go through these in turn, while simultaneously introducing various aspects of coding in Lean.

### 2.1. DEFINITION

A CKM matrix is a $3 \times 3$ unitary matrix. To digitalise this information in HepLean we define the 'type' (which can be thought of as a 'set') of CKM matrices as follows: ${ }^{2}$

```
/-- The type of CKM matrices. -/ (source)
def CKMMatrix : Type := unitaryGroup (Fin 3) }\mathbb{C
```

Here unitaryGroup and the complex numbers $\mathbb{C}$ are imported from MathLib. Types have members, roughly corresponding to elements of a set. In Lean this is written as ( $\mathrm{V}$ : CKMMatrix), which says that $\mathrm{V}$ is a member of the type CKMMatrix. Thus, here it tells us (and Lean) that $\mathrm{V}$ is a $3 \times 3$-unitary matrix.

In physics, it is common to denote the elements of a CKM matrix $V$ as follows:

$$
\left(\begin{array}{lll}
V_{u d} & V_{u s} & V_{u b} \\
V_{c d} & V_{c s} & V_{c b} \\
V_{t d} & V_{t s} & V_{t b}
\end{array}\right)
$$

In Lean one can define notation to closely match this. For instance, if $\mathrm{V}$ is a CKM matrix we can define the Lean notation $[\mathrm{V}] \mathrm{ud}$ as corresponding to the top left element of $\mathrm{V}$. This is done as follows:

```
/-- The 'ud'th element of the CKM matrix. -/ (source)
```

scoped[CKMMatrix] notation (name := ud_element) "[" V "]ud" => V.1 0 0

We can then use the notation $[\mathrm{V}]$ ud in statements of definitions and theorems. We will see this used in the following subsections.

### 2.2. RELATIONS BETWEEN ELEMENTS

A CKM matrix, being unitary, has many relations between its elements. For example, each row is normalised to 1 . HepLean contains these relations as short Lemmas. We do this so that it is easy to use these relationships in the proofs or calculations of more substantial results.[^1]

To give an example, the lemma that the first row of a CKM matrix is normalised to 1 appears in HepLean as follows:

```
lemma fst_row_normalized_abs (V : CKMMatrix) :
        abs [V]ud - 2 + abs [V]us - 2 + abs [V]ub - 2 = 1 := by
    *
```

(source)

We omit the proof here, replacing it with '...' (it can be found by following the '(source)' link given in the code snippet). In this theorem the notation 'abs [V]ud' indicates the absolute value of the complex number [V]ud. This notation, along with many properties of the complex numbers, is imported from MathLib.

It is worth repeating at this point that MathLib allows us to write results at a high-level, despite the dependent type theory foundations of Lean.

### 2.3. EQUIVALENCE RELATION

We now turn to the equivalence relation defined on the type (or set) of CKM matrices. Two CKM matrices are equivalent if they are equal up-to phase-shifts in the quarks. In HepLean the underlying relation appears as:

```
/-- The equivalence relation between CKM matrices. -/ (source)
def phaseShiftRelation (U V : unitaryGroup (Fin 3) C) : Prop :=
    \exists a b c e f g , U = phaseShift a b c * V * phaseShift e f g
```

Here 'phaseShift a b c' corresponds to the unitary matrix $\operatorname{diag}\left(e^{i a}, e^{i b}, e^{i c}\right)$ (source). In HepLean this is followed by a lemma, phaseShiftRelation_equiv (source), stating that phaseShiftRelation is an equivalence relation.

With this equivalence relation we can tell Lean to treat CKMMatrix as a setoid which is simply a type (or set) with a specified equivalence relation. This is done as follows:

instance CKMMatrixSetoid : Setoid CKMMatrix :=

(source)

〈phaseShiftRelation, phaseShiftEquivRelation〉

At this point CKMMatrix is now the structure of a Type with an equivalence relation. We can use, for example, the notation $\mathrm{V} \approx \mathrm{U}$ as a statement in Lean that $\mathrm{V}$ and $\mathrm{U}$ are to be treated as equivalent under this relation. Similarly, we can use 'Quotient CKMMatrixSetoid' for the type of equivalence classes of CKM matrices under the equivalence relation.

### 2.4. INVARIANTS

An invariant of a CKM matrix is a function from the set of CKM matrices to, for example, the complex or real numbers which is well-defined on equivalence classes. There are a number of invariants of CKM matrices currently defined in HepLean. Here we will focus on one, the complex Jarlskog invariant [12].

The complex Jarlskog invariant of a CKM matrix $V$ is $V_{u s} V_{c b} V_{u b}^{*} V_{c s}^{*}$. In HepLean this is defined as follows:

| /-- The complex jarlskog invariant for a CKM matrix. -/ |
| :--- |
| def jarlskogCCKM (V : CKMMatrix) : $\mathbb{C}:=[V] u s *[V] c b *$ conj [V]ub * conj [V]cs |

Here conj is complex conjugation. We note in Lean we could have equivalently defined it as a map CKMMatrix $\rightarrow \mathbb{C}$, something we will see for jarlskog $\mathbb{C}$ below.

It is easy to check by hand that the complex Jarlskog invariant is well-defined on equivalence classes. In HepLean this result appears as the following lemma:

```
lemma jarlskogCCKM_equiv (V U : CKMMatrix) (h : V $\approx$ U) :

```

![](https://cdn.mathpix.com/cropped/2024_06_04_ecb79c70f7188cdd55a7g-07.jpg?height=49&width=694&top_left_y=741&top_left_x=338)

```
    obtain $\langle\mathrm{a}, \mathrm{b}, \mathrm{c}, \mathrm{e}, \mathrm{f}, \mathrm{g}, \mathrm{h}\rangle:=\mathrm{h}$
    change V = phaseShiftApply U a b c e f g at h
    rw [h]
    simp only [jarlskogCCKM, Fin.isValue, phaseShiftApply.ub,
    phaseShiftApply.us, phaseShiftApply.cb, phaseShiftApply.cs]
    simp $[\leftarrow$ exp_conj, conj_ofReal, exp_add, exp_neg]
    have ha : cexp ( $\uparrow a *$ I $) \neq 0$ := exp_ne_zero _
    have hb : $\operatorname{cexp}(\uparrow b * \mathrm{I}) \neq 0$ := exp_ne_zero _
    have hf : cexp ( $\uparrow$ f * I) $\neq 0$ := exp_ne_zero _
    have hg : cexp ( $\uparrow g$ * I) $\neq 0$ := exp_ne_zero _
    field_simp
    ring
```

This lemma takes as an input two CKM matrices $V$ and $U$ as well as the assumption (or proof) $\mathrm{h}$ that $V \approx U$. Note the proof of this lemma relies on the powerful tactics simp, field_simp and ring which automate much of the proof for us.

We can encode the fact that the Jarlskog is well-defined on equivalence classes by redefining it as a map from 'Quotient CKMMatrixSetoid' to the complex numbers ' $\mathbb{C}$ '. In HepLean this is done as follows:

```
/-- The complex jarlskog invariant for an equivalence class
of CKM matrices. -/

```

![](https://cdn.mathpix.com/cropped/2024_06_04_ecb79c70f7188cdd55a7g-07.jpg?height=46&width=894&top_left_y=1936&top_left_x=267)

```
    Quotient.lift jarlskogCCKM jarlskogCCKM_equiv
```


### 2.5. STANDARD PARAMETERISATION

Given four real numbers $\theta_{12}, \theta_{13}, \theta_{23}$ and $\delta_{13}$ one can write down the matrix

$$
\left(\begin{array}{ccc}
c_{12} c_{13} & s_{12} c_{13} & s_{13} e^{-i \delta_{13}} \\
-s_{12} c_{23}-c_{12} s_{13} s_{23} i_{13} & c_{12} c_{23}-s_{12} s_{13} s_{23} e^{i \delta_{13}} & s_{23} c_{13} \\
s_{12} s_{23}-c_{12} s_{13} c_{23} e^{i \delta_{13}} & -c_{12} s_{23}-s_{12} s_{13} c_{23} e^{i \delta_{13}} & c_{23} c_{13}
\end{array}\right)
$$

where $c_{12}=\cos \theta_{12}, S_{12}=\sin \theta_{12}$ etc. This is a $3 \times 3$ unitary matrix, and thus represents a CKM matrix. A CKM matrix written in this form is in the 'standard parameterisation' [13].

In HepLean this matrix (as a matrix and not a CKM matrix) is defined as follows:

```
/-- Given four reals ' $\theta_{12} \quad \theta_{13} \theta_{23} \delta_{13}$ ' the standard
    (source)
paramaterization of the CKM matrixas a ' $3 \times 3$ ' complex matrix. -/
def standParamAsMatrix ( $\theta_{12} \theta_{13} \theta_{23} \delta_{13}: \mathbb{R}$ ) : Matrix (Fin 3) (Fin 3) $\mathbb{C}$ :=
    ![![Real.cos $\theta_{12} *$ Real.cos $\theta_{13}$, Real.sin $\theta_{12} *$ Real.cos $\theta_{13}$,
    Real.sin $\left.\theta_{13} * \exp \left(-\mathrm{I} * \delta_{13}\right)\right]$,
        ![(-Real.sin $\theta_{12} *$ Real.cos $\theta_{23}$ ) - (Real.cos $\theta_{12} *$ Real.sin $\theta_{13} *$ Real.sin $\theta_{23}$
            $* \exp \left(I * \delta_{13}\right)$ ), Real.cos $\theta_{12} *$ Real.cos $\theta_{23}-$ Real.sin $\theta_{12} *$ Real.sin $\theta_{13} *$
            Real.sin $\theta_{23} * \exp \left(\mathrm{I} * \delta_{13}\right.$ ), Real.sin $\theta_{23} *$ Real.cos $\theta_{13}$ ],
        ! [Real.sin $\theta_{12} *$ Real.sin $\theta_{23}$ - Real.cos $\theta_{12} *$ Real.sin $\theta_{13} *$ Real.cos $\theta_{23}$
            $* \exp \left(\mathrm{I} * \delta_{13}\right.$ ), (-Real. $\cos \theta_{12} *$ Real.sin $\theta_{23}$ ) - (Real.sin $\theta_{12} *$ Real.sin $\theta_{13}$
            * Real. $\cos \theta_{23} * \exp \left(\mathrm{I} * \delta_{13}\right.$ )), Real. $\cos \theta_{23} *$ Real.cos $\theta_{13}$ ]]
```

To lift it to a CKM matrix we must show it is unitary. In HepLean, we do this in a lemma called standParamAsMatrix_unitary (source). We can then define the standard parameterisation as a CKM matrix as follows:

```
/-- Given four reals ' $\theta_{12} \quad \theta_{13} \quad \theta_{23} \delta_{13}$ ' the standard paramaterization
of the CKM matrix as a CKM matrix. -/
def standParam ( $\left.\theta_{12} \theta_{13} \theta_{23} \delta_{13}: \mathbb{R}\right):$ CKMMatrix :=
    〈standParamAsMatrix $\theta_{12} \quad \theta_{13} \quad \theta_{23} \quad \delta_{13}$, by
    rw [mem_unitaryGroup_iff']
(source)
    exact standParamAsMatrix_unitary $\begin{array}{lllll}\theta_{12} & \theta_{13} & \theta_{23} & \delta_{13}\end{array}$
```

The standard parameterisation is useful because it is true that every CKM matrix up to equivalence can be written in the standard parameterisation. In HepLean this appears as the following theorem:

```
theorem exists_for_CKMatrix (V : CKMMatrix) :

```

![](https://cdn.mathpix.com/cropped/2024_06_04_ecb79c70f7188cdd55a7g-08.jpg?height=54&width=1105&top_left_y=1672&top_left_x=336)

```
    *
```

(source)

We have omitted the proof since it depends on a number of lemmas not given here.

In this section we have presented how results from CKM matrices are digitalised in HepLean. We have seen the use of complex numbers and equivalence relations in Lean, and gone through some basic aspects of coding in Lean.

## 3. ANOMALY CANCELLATION

When extending a gauge theory by a $\mathfrak{u}(1)$ Lie algebra factor, each fermion gains a charge with respect to that $\mathfrak{u}(1)$. If the $\mathfrak{u}(1)$ comes from a $U(1)$ Lie group, then these charges can be scaled to rational numbers. For a consistent theory the charges cannot be chosen arbitrarily. In particular, they must satisfy a series of polynomial equations arising from triangle Feynman diagrams, which ensure the cancellation of local anomalies. We call these equations the anomaly cancellation conditions (ACCs).

HepLean has the digitalisation of the main results of a series of papers in the area of local anomaly cancellation. Firstly, HepLean contains the parameterisation of the solutions to the ACCs for a pure $U(1)$-gauge theory with an even (see e.g., source) and odd number of fermions (see e.g, source) [14, 15], for a $U(1)$-extension to the Standard Model (SM) with three right handed neutrinos (see e.g., source) [16],
and for a $U(1)$-extension to the Minimal Supersymmetric Standard Model with three right handed neutrinos (see e.g., source) [17]. Secondly, it contains the main result of [18] which will be discussed in $\S 3.3$.

In this section, for illustration purposes, we will focus our attention on a small generalisation of the set-up of [18]. Specifically, the extension of the $\mathfrak{s u}(3) \times \mathfrak{s u}(2)$ gauge algebra of the $\mathrm{SM}$ to $\mathfrak{s u}(3) \times$ $\mathfrak{s u}(2) \times \mathfrak{u}(1)$ assuming $n$-families of $\mathrm{SM}$ fermions. We will summarise some definitions involved, discuss permutations among families, and finish by briefly discussing the main result of [18] which holds for the $n=1$ case. In this section we will see the use of group actions, representation theory, and linear maps in Lean.

### 3.1. DEFINITIONS

To extend $\mathfrak{s u}(3) \times \mathfrak{s u}(2)$ to $\mathfrak{s u}(3) \times \mathfrak{s u}(2) \times \mathfrak{u}(1)$ we need to associate to each fermion of the $\mathrm{SM}$ a rational charge. The set of all possible rational charges forms a $(5 \times n)$-dimensional vector-space over the rationals. The 5 comes from the five species of the SM $Q, U, D, E$, and $L$, and $n$ comes from the $n$-families (so e.g., we have $n$ copies of $Q$, one in each family). In HepLean this vector space appears as (SMCharges n).charges (see e.g., source and source). Given an element (S : (SMCharges n).charges) we define the notation ' $Q$ S i' (source) for the charge associated to the left-handed quark in the $i$ th family, and similar for other species involved.

One of the anomaly equations the charges must satisfy is the $\mathfrak{s u}(2)$-anomaly equation. This is a polynomial equation of degree 1 in the charges. In HepLean it is defined as a linear map (denoted ' $\rightarrow 1[\mathbb{Q}]$ ') from the vector space (SMCharges $\mathrm{n}$ ). charges to $\mathbb{Q}$ as follows:

```
/-- The 'su(2)' anomaly equation. -/
(source)
def accSU2 : (SMCharges n).charges $\rightarrow 1[\mathbb{Q}] \mathbb{Q}$ where
    toFun S := $\Sigma$ i, (3* Q S i + L S i)
    map_add' S T := by
        simp only
        repeat rw [map_add]
        simp [Pi.add_apply, mul_add]
        repeat erw [Finset.sum_add_distrib]
        ring
    map_smul' a S := by
        simp only
        repeat erw [map_smul]
        simp [HSMul.hSMul, SMul.smul]
        repeat erw [Finset.sum_add_distrib]
        repeat erw [ $\leftarrow$ Finset.mul_sum]
        ring
```

Note, to define accSU2 as a linear map, we have to provide the function of sets toFun and prove that it is linear with respect to addition map_add' and scalar multiplication map_smul'. A set of charges respects the $\mathfrak{s u}(2)$-ACC if it is in the kernel of the map accSU2.

The $\mathfrak{s u}(2)$ anomaly equation is not the only ACC which must be satisfied by the charges. There are also the linear gravitational ACC defined in HepLean as the linear map accGrav (source); the linear $\mathfrak{s u}(3)$-ACC defined as the linear map accSU3 (source); and, the non-linear cubic ACC associated to a Feynman diagram with three $\mathfrak{u}(1)$ 's. HepLean denotes this latter ACC as accCube and defines it as a
$\mathbb{Q}$-equivariant map from (SMCharges $\mathrm{n}$ ). charges to $\mathbb{Q}$, where $a \in \mathbb{Q}$ acts on the former vector space by scalar multiplication and on the latter by $b \mapsto a^{3} b$ (source).

### 3.2. PERMUTATIONS AMONG SPECIES

There is a permutation group acting on the vector space of charges given by the permutation between families (or equivalently among species). For our set-up this group is $S_{n}^{\times 5}$ where $S_{n}$ is the permutation group of $n$-objects. In HepLean, we define this group as follows:

/-- The group of ${ }^{6} \mathrm{~S}_{n}{ }^{6}$ permutations for each species. -/ (source) def permGroup (n : $\mathbb{N}$ ) := (_ : Fin 5), Equiv.Perm (Fin n)

This group acts on the vector-space of charges in the natural way. In HepLean this action is defined via a representation as follows:

```
/-- The representation of '(permGroup n)' acting on the vector space (source)
of charges. -/
def repCharges {n : NN} : Representation }\mathbb{Q}\mathrm{ (permGroup n) (SMCharges n).charges where
    toFun :=...
    map_mul' f g := by ...
    map_one, := by ...
```

This uses the type 'Representation _ _ _' defined in MathLib. To define this representation we have to provide a function from the group to the linear maps of the vector space, and show that this obeys the usual properties of representation with respect to multiplication map_mul' and the identity map_one'.

All four ACCs are invariant under this group action. As an example, the lemma that the $\mathfrak{s u}(2)$-ACC is invariant appears in HepLean as follows:

```
lemma accSU2_invariant (f : permGroup n) (S : (SMCharges n).charges) : (source)
    accSU2 (repCharges f S) = accSU2 S :=
    accSU2_ext
        (by simpa using toSpecies_sum_invariant 1 f S)
```

Again it is important to reiterate that once proved, these theorems can be used to help prove more complicated results.

### 3.3. EXCLUDING THE GRAVITATIONAL ANOMALY

In [18] the authors looked at the $n=1$ case of extending the $\mathfrak{s u}(3) \times \mathfrak{s u}(2)$ gauge algebra of the SM to $\mathfrak{s u}(3) \times \mathfrak{s u}(2) \times \mathfrak{u}(1)$ assuming $n$-families of $\mathrm{SM}$ fermions. This corresponds to 1-family, or equivalently the family-universal scenario. They studied solutions to the ACCs excluding the gravitational one. In HepLean we define 'SMNoGrav n' (source) which is a member of a type called ACCSystem (source). Here, all we need to know is that '(SMNoGrav $\mathrm{n}$ ). Sols' is the type of solutions to the $\mathfrak{s u}(2), \mathfrak{s u}(3)$ and cubic ACCs.

The authors of [18] show that any solution to these three ACCs automatically satisfies the fourth ACC, the gravitational one (assuming rationality of charges as done here). In HepLean this appears as
follows:

```
/-- Any solution to the ACCs without gravity satisfies (source)
the gravitational ACC. -/
theorem accGravSatisfied {S : (SMNoGrav 1).Sols} (FLTThree : FermatLastTheoremWith
    Q 3):
    accGrav S.val = 0 := by
by_cases hQ : Q S.val (0 : Fin 1)=0
exact accGrav_Q_zero hQ
exact accGrav_Q_neq_zero hQ FLTThree
```

The proof of this result is interesting since it ultimately depends on Fermat's last theorem for exponent 3. At the time of writing, a proof of this is not present in MathLib, and therefore is added as an assumption to the theorem.

## 4. HIGGS PHYSICS

Currently, in HepLean there are a number of results related to the SM Higgs boson, and scalar potential. In this section we present a broad overview of this digitisation. We will start by defining the target vector space of the Higgs boson, followed by discussing the minimisation of the potential, defining generic Higgs fields, and finally discussing the smoothness properties of the potential as a function of spacetime.

### 4.1. TARGET VECTOR SPACE OF THE HIGGS

The SM Higgs boson takes values in the vector space $\mathbb{C}^{2}$. This vector space comes naturally equipped with the structure of an inner-product that will be useful in defining the Higgs potential. In HepLean we call this vector space higgsVec and define it as follows:

/-- The complex vector space in which the Higgs field takes values. -/ (source) abbrev higgsVec := EuclideanSpace $\mathbb{C}$ (Fin 2)

In MathLib there is an instance of an inner-product structure on EuclideanSpace $\mathbb{C}$ (Fin 2). The use of abbrev in our definition above, rather than def, induces for free an inner-product structure on higgsVec from that on EuclideanSpace $\mathbb{C}$ (Fin 2)

### 4.2. MINIMISING THE POTENTIAL

The vector space higgsVec has another possible interpretation. It is the vector space of those Higgs fields which are constant with respect to spacetime. For one of these fields $\phi$ the SM scalar potential is a number in $\mathbb{R}$ (rather than a map from spacetime to $\mathbb{R}$ ) given by:

$$
V=-\mu^{2}|\phi|^{2}+\lambda|\phi|^{4}
$$

for $\mu^{2}$ and $\lambda$ real parameters. HepLean defines this scalar potential as follows:

```
/-- The higgs potential for 'higgsVec', i.e. for constant higgs fields. -/ (source)
def potential ( }\mu\mathrm{ Sq lambda : RR) ( }\varphi\mathrm{ : higgsVec) : }\mathbb{R}:=-\mu\textrm{Sq * * |\varphi| ~ 2 +
    lambda * |\varphi| ~ 4
```

In the case when $\mu^{2}$ is negative, the minimum of this potential occurs at $\phi=0$. This tells us that the vacuum-expectation value of the Higgs boson for these values of $\mu^{2}$ is zero, and no symmetry-breaking occurs. In HepLean, this property of the potential appears as the following lemma:

![](https://cdn.mathpix.com/cropped/2024_06_04_ecb79c70f7188cdd55a7g-12.jpg?height=54&width=1544&top_left_y=764&top_left_x=256)
(hLam : 0 < lambda) (h\muSq : \muSq \leq 0) :

```
![](https://cdn.mathpix.com/cropped/2024_06_04_ecb79c70f7188cdd55a7g-12.jpg?height=48&width=1039&top_left_y=867&top_left_x=337)
```

    * 
    ```

Note that the proposition in this lemma 'IsMinOn (potential $\mu \mathrm{Sq}$ lambda) Set.univ $\varphi$ ' is defined only to be true when $\varphi$ is a global (due to Set.univ) minimum of the potential.

In the case when $\mu^{2}$ is positive, the minimum of this potential occurs at non-zero $\phi$. This tells us that the vacuum-expectation value of the Higgs boson for this phase is non-zero, and that we have symmetrybreaking. In HepLean, this property of the potential appears as the following lemma:

```

lemma IsMinOn_potential_iff_of_\muSq_nonneg {\muSq lambda : \mathbb{R}}
(source)
(hLam : 0 < lambda) (h\muSq : 0 \leq \muSq) :
IsMinOn (potential \muSq lambda) Set.univ }\varphi\leftrightarrow|\varphi|-2=\mu\textrm{Sq /(2* lambda) := by
..

```

\subsection*{4.3. THE HIGGS FIELD}

Spacetime for the SM is $\mathbb{R}^{4}$ as a manifold. In HepLean we define spacetime as:

```

/-- The space-time -/
abbrev spaceTime := EuclideanSpace }\mathbb{R}\mathrm{ (Fin 4)

```

(source)

Defining spaceTime using MathLib's EuclideanSpace allows us to easily put a smooth structure on it. A Minkowski metric could be added latter, but is not needed here.

Higgs fields generically (i.e., not just constant ones) are most properly defined as smooth sections of the trivial vector bundle $\mathbb{R}^{4} \times \mathbb{C}^{2} \rightarrow \mathbb{R}^{4}$, which simply corresponds to smooth maps from spacetime to $\mathbb{C}^{2}$. This vector bundle in HepLean is defined as follows:

```

/-- The trivial vector bundle }\mp@subsup{\mathscr{R}}{}{2}\times\mp@subsup{\mathbb{C}}{}{2}.-
(source)
abbrev higgsBundle := Bundle.Trivial spaceTime higgsVec

```

HepLean defines the type of Higgs fields to be the type of smooth sections of this vector bundle as follows:

\subsection*{4.4. SMOOTHNESS OF THE POTENTIAL}

In $\S 4.2$ we discussed the Higgs potential for constants Higgs fields and found its minima. Here we will discuss the Higgs potential for generic Higgs fields and its smoothness.

For a Higgs field $\phi: \mathbb{R}^{4} \rightarrow \mathbb{C}^{4}$ the potential at $x \in \mathbb{R}^{4}$ is given by:

$$
V(x)=-\mu^{2}|\phi(x)|^{2}+\lambda|\phi(x)|^{4}
$$

This is a smooth map on spacetime.

In HepLean we first define the map $\mathbb{R}^{4} \rightarrow \mathbb{R}: x \mapsto|\phi(x)|^{2}$ as follows:

```

/-- Given a 'higgsField', the map 'spaceTime }->\mp@subsup{\mathbb{R}}{}{\prime}\mathrm{ obtained (source)
by taking the square norm of the higgs vector. -/

```
![](https://cdn.mathpix.com/cropped/2024_06_04_ecb79c70f7188cdd55a7g-13.jpg?height=46&width=1282&top_left_y=1165&top_left_x=256)

Since $\varphi$ is smooth we expect this map to be smooth, but as it is defined here, Lean only knows it is a map from one type (set) to another. We must demonstrate to Lean that it is smooth with respect to the appropriate smooth structures on spacetime and on $\mathbb{R}$. This is done using the following lemma:

```

lemma normSq_smooth ( }\varphi\mathrm{ : higgsField) :
(source)
Smooth }\mathscr{I(}\mathbb{R}\mathrm{ , spaceTime) }\mathscr{I(}\mathbb{R},\mathbb{R})\varphi.\mathrm{ normSq := by
rw [normSq_expand]
refine Smooth.add ?_ ?_
simp only [mul_re, conj_re, conj_im, neg_mul, sub_neg_eq_add]
refine Smooth.add ?_ ?_
refine Smooth.smul ?_ ?_
exact }\varphi\mathrm{ .apply_re_smooth 0
exact }\varphi\mathrm{ .apply_re_smooth 0
refine Smooth.smul ?_ ?_
exact \varphi.apply_im_smooth 0
exact }\varphi\mathrm{ .apply_im_smooth 0
simp only [mul_re, conj_re, conj_im, neg_mul, sub_neg_eq_add]
refine Smooth.add ?_ ?_
refine Smooth.smul ?_ ?_
exact \varphi.apply_re_smooth 1
exact \varphi.apply_re_smooth 1
refine Smooth.smul ?_ ?_
exact }\varphi\mathrm{ .apply_im_smooth 1
exact \varphi.apply_im_smooth 1

```

As can be seen, the proof of this lemma relies on a series of properties of smoothness already encoded into MathLib. For example, Smooth.add is the lemma that the addition of two smooth functions is also smooth.

In HepLean we then define the Higgs potential for a generic Higgs field as follows:

```

/-- The Higgs potential of the form ' - 年* |\varphi\mp@subsup{|}{}{2}+\lambda*|\varphi\mp@subsup{|}{}{46}.-/}\mathrm{ (source)
def potential ( }\varphi\mathrm{ : higgsField) ( }\mu\mathrm{ Sq lambda : }\mathbb{R}\mathrm{ ) (x : spaceTime) : }\mathbb{R}:
- }\mu\textrm{Sq}*\varphi.\mathrm{ normSq x + lambda * }\varphi.\mathrm{ normSq x *

```

Note that this now has a point in spacetime as a parameter, unlike for the potential for constant Higgs fields in $\S 4.2$.

The potential for fixed $\varphi, \mu \mathrm{Sq}$ and lambda is (as far as Lean knows) only a map of types from spacetime to $\mathbb{R}$. We thus provide a lemma in HepLean showing that it is also smooth as follows:

```

lemma potential_smooth ( }\varphi\mathrm{ : higgsField) ( }\mu\mathrm{ Sq lambda : }\mathbb{R}\mathrm{ ) : (source)
Smooth }\mathscr{I}(\mathbb{R},\mathrm{ spaceTime) }\mathscr{I}(\mathbb{R},\mathbb{R})\mathrm{ (fun x =>
simp only [potential, normSq, neg_mul]
exact Smooth.add
(Smooth.neg (Smooth.smul smooth_const \varphi.normSq_smooth))

```
![](https://cdn.mathpix.com/cropped/2024_06_04_ecb79c70f7188cdd55a7g-14.jpg?height=54&width=1322&top_left_y=1041&top_left_x=338)

\section*{5. FUTURE WORK}

HepLean is an ongoing project. The long-term goal is to digitalise the whole of high energy physics within HepLean. With the development of new results in high energy physics, this long-term goal is potentially unreachable as the goalpost is ever moving. Thus, in this section we will discuss the author's short-term goals for HepLean.

The first goal is to digitalise some results from the two-Higgs doublet model (2HDM). In particular, we will digitalise aspects of the 2HDM scalar potential, similar to that of the Higgs field, discussed in $\S 4$. This project should be fairly straightforward, and will provide an explicit example of a digitalisation of beyond-the-standard-model physics.

The second goal is to digitalise some aspects of fermions and more generic Lorentz group representations. In particular, the aim will be to set up notation and definitions in HepLean to make it easier to write down invariants of the Lorentz group in a style that high energy physicists are familiar with.

The third goal is to digitalise some aspects of the theory of generalised symmetries. Thus far, the material in HepLean leans towards the phenomenology side of the field. Digitalising aspects of generalised symmetries will give an example of more formal areas in HepLean.

The fourth goal is to digitalise some aspects of experimental data. In HepLean one should be able to compare theoretical predictions with experimental data. This project will involve understanding the best way to write experimental data in Lean, and give an example in HepLean of a comparison of theory to experiment. A particular candidate for this is CKM matrices, which has results digitalised into HepLean as discussed in $\S 2$.

The fifth goal is to work on increasing the collaborative nature of HepLean, and getting more people involved. We plan to do this by creating a high energy physics Lean game in order to teach physicists how to write Lean code. (On a side note, as a teaching resource, we plan to make Lean games for different areas of high energy physics.) Another way we plan to increase the collaborative nature of HepLean is by making a list of theorems and results to be digitalised, each graded by their expected
difficulty. We hope this will make it easier for physicists to jump into digitalisation.

With that, if you are interested in contributing to HepLean, please feel free to either make a pullrequest on the HepLean GitHub, or connect on the Lean Zulip channel (an online forum where most discussions about Lean and MathLib take place).

\section*{ACKNOWLEDGMENTS}

I thank the members of the Lean Zulip for helpful discussions, with particular thanks to Tyler Josephson. I thank Margarita Gavrilova and Yuval Grossman for discussions about digitalising aspects of flavour physics. I also thank Csaba Csáki, Thomas Hartman, Baur Mukhametzhanov, and Maximilian Ruhdorfer for helpful discussions about digitalising of physics in general. The author is supported by the U.S. National Science Foundation (NSF) grant PHY-2014071.

\section*{REFERENCES}

[1] Leonardo De Moura, Soonho Kong, Jeremy Avigad, Floris Van Doorn, and Jakob von Raumer. The lean theorem prover (system description). In Automated Deduction-CADE-25: 25th International Conference on Automated Deduction, Berlin, Germany, August 1-7, 2015, Proceedings 25, pages 378-388. Springer, 2015. doi:10.1007/978-3-319-21401-6_26.

[2] The mathlib Community. The lean mathematical library. In Proceedings of the 9th ACM SIGPLAN International Conference on Certified Programs and Proofs, CPP 2020, page 367-381, New York, NY, USA, 2020. Association for Computing Machinery. doi:10.1145/3372885 . 3373824.

[3] Maxwell P Bobbin, Samiha Sharlin, Parivash Feyzishendi, An Hong Dang, Catherine M Wraback, and Tyler R Josephson. Formalizing chemical physics using the lean theorem prover. Digital Discovery, 3(2):264-280, 2024. doi:/10 . 1039/D3DD00077J.

[4] Tomáš Skřivan. Scilean: Scientific computing assistant. GitHub repository. URL: https://github.com/lecopivo/SciLean.

[5] Eric Hanqing Lu. A formalization of elements of special relativity in coq. 2017. URL: http://nrs.harvard.edu/urn-3:HUL. InstRepos:38811518.

[6] Kevin Hartnett. Building the mathematical library of the future. Quanta Magazine, 2020.

[7] Joachim Breitner. loogle. GitHub repository. URL: https://github.com/nomeata/loogle.

[8] Kaiyu Yang, Aidan M. Swope, Alex Gu, Rahul Chalamala, Peiyang Song, Shixing Yu, Saad Godil, Ryan Prenger, and Anima Anandkumar. Leandojo: Theorem proving with retrieval-augmented language models. 2023. arXiv:2306.15626.

[9] Alexander Bentkamp and Jon Eugster. Lean game server. URL: https://adam.math.hhu.de/\#/.

[10] Kevin Buzzard, Jon Eugster, and Mohammad Pedramfar. The natural number game. URL: https://adam.math.hhu.de/\#/g/leanprover-community/nng4.

[11] Daniel J. Velleman. The set theory game. URL: https://adam.math.hhu.de/\#/g/djvelleman/stg4.

[12] C. Jarlskog. Commutator of the quark mass matrices in the standard electroweak model and a measure of maximal CP nonconservation. Phys. Rev. Lett., 55:1039-1042, Sep 1985. doi:10.1103/PhysRevLett.55.1039.

[13] Ling-Lie Chau and Wai-Yee Keung. Comments on the parametrization of the kobayashi-maskawa matrix. Phys. Rev. Lett., 53:1802-1805, Nov 1984. doi:10.1103/PhysRevLett.53.1802.

[14] Davi B. Costa, Bogdan A. Dobrescu, and Patrick J. Fox. General Solution to the U(1) Anomaly Equations. Phys. Rev. Lett., 123(15):151601, 2019. arXiv:1905.13729, doi:10.1103/PhysRevLett.123.151601.

[15] B. C. Allanach, Ben Gripaios, and Joseph Tooby-Smith. Geometric General Solution to the $U(1)$ Anomaly Equations. JHEP, 05:065, 2020. arXiv:1912.04804, doi:10.1007/JHEP05(2020)065.

[16] B. C. Allanach, Ben Gripaios, and Joseph Tooby-Smith. Anomaly cancellation with an extra gauge boson. Phys. Rev. Lett., 125(16):161601, 2020. arXiv:2006.03588, doi:10.1103/PhysRevLett. 125.161601.

[17] B. C. Allanach, Maeve Madigan, and Joseph Tooby-Smith. A $v$ supersymmetric anomaly-free atlas. JHEP, 02:144, 2022. arXiv:2107.07926, doi:10.1007/JHEP02(2022) 144.

[18] Nakarin Lohitsiri and David Tong. Hypercharge Quantisation and Fermat's Last Theorem. SciPost Phys., 8(1):009, 2020. arXiv:1907.00514, doi:10.21468/SciPostPhys.8.1.009.```


[^0]:    ${ }^{1}$ Proof: $-1+1=2$.

[^1]:    ${ }^{2}$ For each code snippet in this paper from HepLean we provide a link '(source)' to that code in a stable version of HepLean. For presentational purposes, small variations may exist between the code snippet appearing in this paper and that found following the link.

