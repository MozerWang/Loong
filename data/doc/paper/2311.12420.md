# How Far HaVe We Gone in VUlNerabilitY DeTECTION USING LARGE LANGUAGE MODELS 

Zeyu Gao $^{1}$ Hao Wang ${ }^{1} \quad$ Yuchen Zhou $^{2} \quad$ Wenyu Zhu ${ }^{1}$ Chao Zhang ${ }^{1}$<br>\{gaozy22,hao-wang20\}@mails.tsinghua.edu.cn<br>zhouyuchen@emails.bjut.edu.cn zhuwy19@mails.tsinghua.edu.cn<br>chaoz@tsinghua.edu.cn<br>${ }^{1}$ Tsinghua University<br>${ }^{2}$ Beijing University of Technology


#### Abstract

As software becomes increasingly complex and prone to vulnerabilities, automated vulnerability detection is critically important, yet challenging. Given the significant successes of Large Language Models (LLMs) in various tasks, there is growing anticipation of their efficacy in vulnerability detection. However, a quantitative understanding of their potential in vulnerability detection is still missing. To bridge this gap, we introduce a comprehensive vulnerability benchmark VulBench. This benchmark aggregates high-quality data from a wide range of CTF (Capture-the-Flag) ${ }^{1}$ challenges and real-world applications, with annotations for each vulnerable function detailing the vulnerability type and its root cause. Through our experiments encompassing 16 LLMs and 6 state-of-the-art (SOTA) deep learning-based models and static analyzers, we find that several LLMs outperform traditional deep learning approaches in vulnerability detection, revealing an untapped potential in LLMs. This work contributes to the understanding and utilization of LLMs for enhanced software security.


## 1 INTRODUCTION

The rapid advancement of software systems has led to an increase in their complexity and susceptibility to vulnerabilities, thereby heightening security risks. Effective vulnerability detection is imperative in this scenario, necessitating robust and automated methods. Traditional techniques like fuzzing, symbolic execution, and static analysis, while valuable, often fall short in addressing the complexities of modern software systems (AFL; Cadar et al., 2008).

In this context, large language models (LLMs) such as GPT-3.5 and GPT-4 have emerged as promising tools. Noted for their broad generalization and reasoning capabilities, these models have shown notable success in diverse applications, including the domain of vulnerability detection (OpenAI, Yang et al. 2023b). Yet, the quantitative assessment of their effectiveness in vulnerability detection is still under-explored.

A significant obstacle in applying LLMs for vulnerability detection is the lack of high-quality, accurate datasets. Prior research shows that existing vulnerability datasets often lack in quality and accuracy, achieving detection correctness rates as low as $30 \%$ to $50 \%$ (Croft et al., 2023; Chen et al., 2023). This not only hampers the ability to effectively evaluate LLMs but also fails to represent the complexities of real-world software vulnerabilities, which often arise from interactions across multiple functions and require a comprehensive understanding of the codebase.

To address these challenges, we introduce VulBench, a comprehensive dataset amalgamating data from various sources, including CTF challenges, MAGMA (Hazimeh et al., 2020), Devign (Zhou et al. 2019), D2A (Zheng et al., 2021), and Big-Vul (Fan et al.| 2020). This dataset offers a blend of straightforward CTF challenges and more complex real-world CVE vulnerabilities, catering to both open-source and closed-source software vulnerability detection scenarios. All datasets are expertly

1 https://ctf-wiki.org/en/
human-labeled, with the CTF and MAGMA datasets additionally providing the necessary context for vulnerability assessment.

We have designed and conducted a comprehensive evaluation process to assess the vulnerability detection capabilities of LLMs. Our assessments are grounded on the multi-level vulnerability data provided within these datasets. Employing two approaches-binary classification to determine the presence of vulnerabilities within functions, and multi-class classification to identify specific types of function vulnerabilities-we facilitate nuanced and in-depth judgments by the models. This evaluative methodology is consistently applied to both deep learning models and static analysis tools, ensuring a uniform standard of evaluation across different systems and models.

Our main contributions are as follows:

- We conduct the first large-scale study to quantitatively measure the performance of 16 LLMs in the field of vulnerability detection, setting a benchmark against state-of-the-art deep learning models and static analyzers.
- The introduction of VulBench, a benchmark that addresses the quality issues prevalent in existing datasets, offering a comprehensive dataset for more accurate evaluations, along with the new natural language description for the vulnerabilities.
- Unveiling the untapped potential of LLMs in vulnerability detection, our findings provide new insights and future research directions in this domain.
- We provide the dataset at https://github.com/Hustcw/VulBench to facilitate future work.

This research not only enhances our understanding of LLMs' application in software security but also opens up new avenues for advancements in automated vulnerability detection.

## 2 RELATED WORK

### 2.1 BACKGROUND FOR VULNERABILITY DETECTION

Vulnerability detection is a crucial task in the field of computer security. Its primary objective is to identify potential software security threats, thus reducing the risk of cyber-attacks. A key resource in this effort is the CVE database (MITRE), which acts as a platform for monitoring these vulnerabilities.

Three principal techniques are employed in vulnerability discovery: fuzzing, symbolic execution, and static analysis. Fuzzing (AFL) seeks to uncover software crashes and anomalies by inundating the system with diverse random inputs. Conversely, symbolic execution (Cadar et al. 2008) aims to detect irregularities by simulating multiple application pathways. Finally, static analysis (Lu et al., 2019, Wu et al., 2021) examines the code without executing it to identify potential vulnerabilities.

Integrating deep learning models into vulnerability exploration often involves feeding source code into the model for classification (Lu et al., 2021, Hanif \& Maffeis, 2022). This approach, which analyzes the code without execution, is generally classified under static analysis. Nevertheless, significant advancements have also been made in utilizing deep learning models to augment fuzzing techniques (Shi et al., 2023, Godefroid et al., 2017).

Listing 1 is an example of a vulnerable function. The data in char buf [10] will overflow into str [10] due to the unsafe usage of gets (buf) ; . The duty of vulnerability detection is to detect that potential stack overflow.

### 2.2 DEEP LEARNING-BASED MODELS FOR VULNERABILITY DETECTION

This research builds upon recent strides in NLP-driven code analysis for vulnerability detection. CodeXGLUE (Lu et al., 2021) works with CodeBERT on the Devign (Zhou et al., 2019) dataset represents a key development in assessing source code vulnerability risk. LineVul (Fu \& Tantithamthavorn, 2022) extends these insights by applying the same model to the Big-Vul dataset for nuanced detection at both function and line levels. Alternatively, VulBERTa (Hanif \& Maffeis, 2022) innovates with a RoBERTa (Liu et al. 2019) model tailored for code through a hybrid BPE-tokenization scheme. The VulDeePecker (Li et al., 2018, Zou et al., 2019; Li et al., 2021) series introduces and iteratively refines the idea of utilizing semantically correlated "code gadgets" and BLSTMs for initial vulnerability identification, then multi-class categorization, and finally precise location via LLVM IR analysis. ReVeal (Chakraborty et al. 2022) rounds out the landscape by proving that the efficacy of vulnerability prediction can be enhanced through the integration of semantic information using gated graph neural networks (GGNN), combined with refined data handling practices.

### 2.3 Large LANGUAGE ModeLS FOR VULNERABILITY DeTECTION

Previous research (OpenAI) has demonstrated the potential of LLMs for detecting software vulnerabilities, although there is a lack of comprehensive vulnerability-focused data. While GPT-3.5 and GPT-4 have been the primary subjects of study, displaying notable capabilities, evaluations of open-access LLMs are less common. Studies present mixed results (Cheshkov et al. 2023); while some LLMs performed on par with naive classifiers, others, specifically GPT-4, have shown significant advantages over conventional static analysis tools (Noever, 2023). Enhancements to exploit the multi-round dialogue proficiency of ChatGPT have prompted improved detection methods (Zhang et al., 2023), and recent advancements (Chan et al., 2023) have fine-tuned LLMs for identifying diverse vulnerability patterns, indicating a potential for reaching expert-level performance in vulnerability management tasks.

### 2.4 BENCHMARKS FOR LLMS

Open LLM Leaderboard (Beeching et al., 2023) and MMLU (Hendrycks et al., 2021) evaluates models on science questions, commonsense inference, etc. MT-bench (Zheng et al. 2023) evaluates chat assistants in aspects of writing, reasoning, code, and so on. Cheshkov et al. (2023) conducts the evaluation of vulnerability detection capability on the OpenAI GPT series. Besides, there are several individual datasets (Zheng et al. 2021; Zhou et al., 2019; Chen et al. 2023) for vulnerability detection.

## 3 DATASET

Contrary to past works that assemble vast datasets with multiple vulnerability types automatically, our focus hinges on the enhancement of the accuracy and validity of datasets. We've gathered from multiple sources relatively condensed yet comprehensive CTF datasets detailing all functions in an executable binary, and real-world datasets providing only partial functions from huge real-world programs. Although CTF problems don't originate from the real world, their associated vulnerabilities typically mirror real-world scenarios, presenting a miniature depiction of the real world.

### 3.1 DATASET OVERVIEW

The dataset amalgamates multiple sources of vulnerabilities, comprising CTF challenges, MAGMA (Hazimeh et al., 2020), and three previous vulnerability datasets (Zheng et al., 2021, Zhou et al. 2019, Fan et al. 2020) with extensively cleaning. They can be mainly divided into three types of data sets as follows. The overview of the dataset is shown in Table 1 and the containing vulnerability types are shown in Table 6

CTF Dataset: In CTF challenges, particularly the PWN category, participants must identify and exploit program vulnerabilities to get the Flag, which serves as evidence of task completion. Despite being shorter than vulnerabilities found in real-world CVEs, there's a significant number of flawed

| Type | Obtaining Method | Source | Features | $\overline{\text { Count }}$ | $\overline{\text { \#Label }}$ |
| :---: | :---: | :---: | :---: | :---: | :---: |
| CTF | PWN Problem | BUUOJ | Raw decompiled code, <br> Reversed decompiled code | 108 | 5 |
| Real World | CVE Commit Diff | MAGMA | Source code, <br> Raw decompiled code | 100 | 8 |
|  |  | Devign | Source code | 70 | 7 |
|  |  | Big-Vul |  | 108 | 9 |
|  | Static Analyzer | $\mathrm{D} 2 \mathrm{~A}$ | Source code | 69 | 4 |

Table 1: Composition and source of the dataset, along with the features available for the model and the count of binaries or functions in the datasets. In the CTF dataset, the count represents the count of individual binary, and there exist multiple functions in a binary. In real-world datasets, the count represents the count of individual bugs, and there exist multiple functions in MAGMA. \#Label refers to the number of different types of vulnerabilities used for multi-label classification in each dataset.

functions within CTF PWN tasks, encompassing a broad range of potential memory-related issues flagged within CVEs. This makes it a suitable and basic method for evaluating the LLM.

CVE Dataset: The CVE dataset typically identifies vulnerable functions by comparing changes made to the code during CVE remediation. This information, derived from real-world software, includes not just memory leak vulnerabilities typical to CTF scenarios but a broader range of realworld vulnerabilities, providing a more strenuous test of LLM's vulnerability detection capabilities.

Static Analyser Generated Dataset: The dataset of potential vulnerabilities, garnered via static analysis, is typically produced using specific tools for this analysis. It involves examining the entirety of a project, where possible weak points are detected by the patterns and constraints. Despite its usefulness, this method usually generates a relatively high rate of false positives.

### 3.2 DATASET CONSTRUCTION

### 3.2.1 CTF

We create a dataset for CTF challenges within the PWN category, by selecting problems from the BUUOJ platform 2 In the CTF, participants are usually only provided with a binary, devoid of source code. To cater to Language Models such as LLM, which are less adept at handling assembly code directly, we use IDA (Interactive Disassembler) (Hex-Rays) to extract more interpretable decompiled code for model input. This is further complicated by the characteristics of the binaries in CTF competitions. They often lack essential debug and symbolization information, leaving them devoid of meaningful structure and variable definitions.

To mitigate this, we engage in manual reverse engineering to enhance the structure of the decompiled code by restoring recognizable constructs, renaming variables, and annotating the size of global variables. It's worth noting that, despite acquiring refined decompiled code via manual reverse engineering, the generated decompiled code often bears intrinsic patterns or code snippets characteristic from the decompiler, which are rare in the LLM's training set. As such, our efforts should focus on optimizing the readability of the decompiled code for LLM and evaluate the utility of such manual interventions in vulnerability detection, instead of aiming to enhance the decompiled code to mirror the actual source code distribution. We give an example in Section E.1 to demonstrate the difference between raw decompiled code and manually reversed decompiled code and the challenges of using decompiled code directly.

As for the metric, aside from the traditional binary classification and multi-class classification, we describe the root causes of identified vulnerabilities using clear, descriptive natural language explanations over the ambiguous practice of referencing code lines. An example is shown in Table 7

2https://buuoj.cn

### 3.2.2 MAGMA

Our study also adopts the MAGMA fuzzing dataset, a specialized collection created to assess the ability of fuzzing tools to trigger hidden vulnerabilities. In the fuzzing process, fuzzers create myriad testcases by mutating inputs randomly and feeding them into the target program. As vulnerabilities do not consistently lead to program crashes, relying solely on the execution state of the program is not an ideal method for detecting whether the vulnerability has been triggered. To address this, the MAGMA dataset includes specialized markers-referred to as 'canaries'-on the execution paths towards the location of vulnerability. When a canary's check returns true, it implies that the vulnerability has been triggered. This approach does not depend on the more rigorous occurrence of program crashes to ascertain the presence of vulnerabilities. When scrutinizing vulnerabilities, we analyze the security patches and 'canaries' to understand the root cause of the flaws. In Section E.2. we give an example of how we utilize this information.

To enhance the analysis, we provide additional context such as macro expressions and correlatable functions related to the vulnerability during the analysis. This additional context is used to simulate a real-world scenario where understanding the relationships between functions can prove pivotal in identifying security vulnerability so that we can assess the model's capability when more context is provided and its resistance to the impact of extraneous information. Also, we provide two input features for LLM, the source code extracted from project repositories and the decompiled code extracted from the compiled binary to mimic the scenarios of closed-source software.

### 3.2.3 DEVIGN, D2A, BIG-VUL

For the purpose of supplementing our research with real-world vulnerability data, we additionally incorporate three prior datasets. These include the D2A dataset proposed by Zheng et al. (2021), the Devign dataset introduced by Zhou et al. (2019), and the Big-Vul dataset discussed in Fan et al. (2020). Nevertheless, we don't directly employ these datasets in their entirety. Rather, we take guidance from previous studies to ensure maximum accuracy and reliability within our dataset.

In Croft et al. (2023), a selection of vulnerability functions are randomly sampled from the triad of datasets. Those are then manually evaluated to ascertain if they represented authentic security patches within the git commit to mitigate the interfering factors such as non-functional changes in the same commit and wrongly identified due to unreliable keyword matching or false positives from static analysis tools. When constructing the dataset, functions verified as true security patches (Related to fixing the vulnerability) are marked as vulnerable. On the other hand, functions that don't qualify as security patches (Related to code cleanup or irrelevant code changes) are designated as non-vulnerable. Furthermore, we also consider patched functions to be invulnerable.

In the annotation process, for Big-Vul dataset, we fuse the descriptions from their CVE pages with existing tags to categorize the types and we illustrate the information provided by Big-Vul dataset and the annotation process in Section E.3. For Devign dataset, it lacks corresponding vulnerability types, leading to our reliance on CVE descriptions to distinguish the vulnerability types. As for the D2A vulnerability dataset, which obtained using a static analysis program that automatically notes the vulnerability type, it has already been tagged by static analysis tools, facilitating our direct reuse.

## 4 EVALUATION

### 4.1 SeleCTED ModelS \& BASELINES

In our experiment, we select a series of large models, including GPT-3.5, GPT-4 and open-access LLMs comprises variations of Llama2 and those that underwent SFT on Llama2. The full list of selected models is in Table 5. We host the models on 48 A800 GPUs across 6 nodes and leverage vLLM (Kwon et al. 2023) and text-generation-inference (Huggingface) to expedite the model inference process. We repeat the requests for 5 times for each vulnerability detection task.

For comparison, we select three deep learning models and three rule-based static analysis tools according to Steenhoek et al. (2023); Lipp et al. (2022) to serve as baselines. The full list and description are shown in the Section B. We exclude the VulDeeLocator (Li et al. 2021; Zou et al. 2019) as it requires a lot of human effort to annotate the execution trace and requires the source code
![](https://cdn.mathpix.com/cropped/2024_06_04_942f7fa7894b71a9768eg-06.jpg?height=870&width=1118&top_left_y=275&top_left_x=508)

Figure 1: Few-shot conversation for binary classification (whether a function is vulnerable) and multi-class classification (which vulnerability does the function have) in CTF dataset. BC stands for binary classification. MC stands for multi-class classification.

compile-able. Using these, we aim to ascertain the degree of superiority, in terms of vulnerability detection, the current LLM possesses compared to traditional methods. Especially, the selected deep learning models can only perform binary classification as it requires retraining to support multi-class classification, but the size of our dataset is too limited to support it.

### 4.2 METRIC

Unlike GPT models that boast of an excellent alignment (Ouyang et al. 2022), other models don't come equipped with a mechanism to seamlessly output in a standard format. To address this situation, we employ the two few-shot methods, 2-shots and 5-shots, to insist on a uniform template for output, making it easier to parse the answer of models. Within all the datasets, we randomly select the examples that serve as our few-shot instances. The prompts are formatted in the style of a chat to ensure alignment with the models' methods. Each dialogue round incorporated a few-shot instance, with the substantive question introduced only from the third round onwards. Figures 3 and 4 offer a clear showcase of the 2 -shot prompt at work.

During binary classification, the model is programmed to channel outputs as VULNERABLE: NO or VULNERABLE: YES. Alternately, in multi-class classification scenarios, the model delivers outputs as TYPE: [type], where [type] corresponds to a selection from an exhaustive list. To minimize parsing complications and take stock of the model's few-shot ability, we take a leaf out of MT Bench's (Zheng et al. 2023) playbook, targeting only the final result that complies with the stipulated format. Model outputs bereft of matching outputs are branded as invalid. Given that the 5 -shots prompt is near 2000 tokens and the context length of Vicuna-33.b-v1. 3 and falcon-40b-instruct are limited to 2048 tokens, not all input may fit within the context length of these models, so we exclude the 5 -shot results of these models.

Table 2: Binary classification results in CTF and real-world datasets on deep-learning-based models.

|  | CTF |  |  | Real-world |  |  |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
|  | F1 | Precision | Recall | F1 | Precision | Recall |
| VulBERTa | 0.354 | 0.350 | 0.391 | 0.406 | 0.456 | 0.388 |
| LineVul | 0.155 | 0.619 | 0.187 | 0.166 | 0.419 | 0.193 |
| CodeXGLUE | 0.375 | 0.341 | 0.617 | 0.429 | 0.437 | 0.462 |

Table 3: Multi-class classification results in CTF dataset on static analyzer tools, BinAbsInspector is provided with the binary, flawfinder and cppcheck is proviced with decompiled code.

|  | Raw Decompiled code / Binary |  |  | Reversed Decompiled code |  |  |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  | F1 | Precision | Recall | F1 | Precision | Recall |
| flawfinder | 0.174 | 0.229 | 0.662 | 0.136 | 0.178 | 0.324 |
| cppcheck | 0.02 | 0.029 | 0.015 | 0.016 | 0.010 | 0.170 |
| BinAbsInspector | 0.604 | 0.652 | 0.563 | $/$ | $/$ | $/$ |

### 4.3 CTF DATASET

### 4.3.1 OVERALL PERFORMANCE

We show the result of binary classification and multi-class classification for a single function with an averaged F1 score over raw decompiled code and manually reversed decompiled code in Figure 1 The results of the static analyzer and deep learning models are shown in Table 3 and Table 2 . The full result of the CTF dataset is shown in Table 12 .

Analysis of the CTF dataset revealed that GPT-4 maintained its acknowledged strong capability in various arenas-be it binary or multi-class classification-garnering impressive results. However, the Llama 2 family with RLHF Ouyang et al. (2022); Christiano et al. (2017) does not achieve projected expectations, suggesting that over-alignment will hurt the capability of the LLM OpenAI When compared to the results of the supervised fine-tuned models of the same size, such as the Platypus or Vicuna, it is seen that these models demonstrated improved performance. Furthermore, concerning different quantities of few-shot examples, there is a notable enhancement in the vulnerability mining capabilities of most models when comparing 5 -shot to 2-shot scenarios.

When comparing with the baselines, static analyzers, and deep learning-based models, the GPT3.5 and GPT-4 outperform the best baselines in terms of F1 in binary classification whereas the open-access models fall behind when compared to VulBERTa and CodeXGLUE. When comparing open-access models that are trained on identical datasets (eg. Llama 2, Vicuna), we notice that while the phenomenon of the scaling law persists, enhancements are notably limited. This indicates that merely augmenting the volume of parameters does not necessarily optimize a model's capacity for vulnerability detection adequately. Accordingly, complementing efforts need to be allocated to enhancing other components, notably the quality of the dataset used. Moreover, in the vulnerability detection domain, substantial disparities still exist between models comparable to GPT-3.5 and large-scale open-access alternatives, despite claims to the contrary.

### 4.3.2 Ablation StUdY ON PRoVIDED INFORMATION

We conduct a comparison of the model's capacity when provided with varying types of information. The lower figure in Figure 8 illustrates the outcome of providing all functions within a binary in the CTF challenge compared to only a single function is provided. Experimental data revealed that when provided with reverse-engineered pseudocode, several models, specifically GPT-4, GPT3.5, Falcon-40b, and Vicuna, demonstrated improved performance, and a decline is less common. It suggests these models, much like humans, comprehend well-formatted and readable code better than merely decompiled code. Interestingly, when comparing performance on giving more context, GPT4 showes stable results whether given a single function or the entire binary, while GPT-3.5's accuracy decreased when exposed to more functions, suggesting that GPT-4 handles additional context more effectively. Regarding open-access models, the majority of them have experienced performance improvements, indicating that given the context allows, acquiring more context can assist the model in making better judgments. This is true even for datasets like CTF, where vulnerabilities often only appear within a single function.

![](https://cdn.mathpix.com/cropped/2024_06_04_942f7fa7894b71a9768eg-08.jpg?height=875&width=1119&top_left_y=278&top_left_x=514)

2-Shot-BC 5-Shot-BC 2-Shot-MC 5-Shot-MC
![](https://cdn.mathpix.com/cropped/2024_06_04_942f7fa7894b71a9768eg-08.jpg?height=826&width=1116&top_left_y=316&top_left_x=510)

Figure 2: Few-shot conversation for binary classification (whether a function is vulnerable) and multi-class classification (which vulnerability does the function have) in the real-world dataset.

Table 4: Multi-class classification results in MAGMA dataset on static analyzer tools, BinAbsInspector is provided with the binary, flawfinder, and cppcheck are provided with decompiled code and source code.

|  | Raw Decompiled code / Binary |  | Source Code |  |  |  |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  | F1 | Precision | Recall | F1 | Precision | Recall |
| flawfinder | 0.064 | 0.043 | 0.191 | 0.052 | 0.035 | 0.369 |
| cppcheck | 0.069 | 0.055 | 0.093 | 0.096 | 0.068 | 0.185 |
| BinAbsInspector | 0.011 | 0.006 | 0.066 | $/$ | $/$ | $/$ |

### 4.4 REAL-WORLD DATASET

Figure 2 showcases data from the real-world dataset as a collective. Along this, the results of the static analyzer and deep learning models are shown in Table 4 and Table 2. The full result on the real-world dataset is shown in Table 13 .

As we delve into the challenging area of real-world vulnerability detection, it is evident that all LLMs, underperform when provided with just a single function. This is due to the fact that a comprehensive understanding of the entire program is needed. Despite this, GPT-4 outperforms other models in scenarios requiring multi-class classifications, where the requisite for high model capabilities is more pronounced. Conversely, performance declines in binary classification scenarios. But when compared with the deep learning models, the LLM performs relatively worse than them. Upon examining their predictions in Section 4.5 and H, we discern that their decreased proficiency often stems from the model's excessive conservatism-namely, its propensity to yield 'No Vulnerability'. This tendency contrasts with that of deep learning models, which, when trained on a specific dataset, strive to make judgments on the input content as far as possible. This may account for certain disparities between large-scale models and deep learning models.

When considering the single magma functions against those offering a more complete context (as depicted in the upper figure in Figure 9, there is negligible performance alteration. The LLMs may find it challenging to discern correctly due to the presence of a large amount of irrelevant normal coding, consequently undermining performance. The lower figure in Figure 9 extends the comparison, juxtaposing the magma source code with the decompiled code extracted using IDA -
a comparison that yields similar results. This outcome is out of sync with those recorded in the CTF competition. We credit this discrepancy to the increased complexity found within the real-world vulnerability dataset as opposed to the CTF dataset.

### 4.5 AnAlysis of the ModelS' Performance

In Section we have presented and analyzed the performance of models on various datasets. It is noteworthy that despite the suboptimal performance of all models on real-world datasets, the reasons for their divergent outcomes are distinct. This includes a common tendency toward conservatism, where the models are inclined to identify the absence of vulnerabilities. Notably, models derived from Reinforcement Learning from Human Feedback (RLHF) exhibit a strong bias towards certain types of vulnerabilities, highlighting that RLHF may align models more closely with human values or preferences, yet could also intensify certain biases. This could potentially conflict with RLHF's intent to minimize biases related to values or safety, rendering it less suitable for other tasks.

## 5 DISCUSSION

### 5.1 EVALUATION ON Root CAUSE DESCRIPTION

In this study, we advocate for a vulnerability dataset characterized by natural language. Given the abundance of results derived from numerous models, manual evaluation of every outcome is impractical. Further complicating matters, the GPT-4's limited comprehension of vulnerabilities restricts its utility as a proficient critic akin to MT Bench (Zheng et al. 2023), thereby undermining the evaluation of the model's results. We envisage an expansion of similar datasets, accompanied by the development of enhanced automated evaluation methodologies.

### 5.2 LIMITATION OF DECOMPILED CODE

We perform vulnerability detection for closed-source software based on decompiled code, but decompiled code itself also has certain limitations, and there will be errors and information loss, preventing the vulnerabilities from being reflected at the decompiled code level. We show a bad case of decompiled code in Section $\mathrm{K}$. The decompilers must adapt to new compiler-generated assembly patterns (Basque et al.), which is a challenge beyond the scope of this study. Better yet, assembly code could be processed directly by an LLM, though its understanding falls short compared to the original decompiled code. Recent advances in effectively encoding assembly language (Pei et al. 2023; Wang et al. 2022) might offer a workaround, allowing an LLM to interpret assembly directly, similar to LLaVA (Liu et al. 2023a), bypassing the need for decompiled code.

### 5.3 FUTURE FOR VULNERABILITY DETECTION WITH LLM

We illustrate how GPT-4 noticeably surpasses other models on relatively simplistic datasets, such as CTF, indicative of its certain proficiency in vulnerability mining. Conversely, when considering the real-world dataset, none of the models, exhibited exceptional vulnerability mining prowess. The increasing complexity of software necessitates a deeper understanding to conduct effective vulnerability research. Enhancing our comprehension of entire projects (Bairi et al. 2023) is crucial to uncover more significant vulnerabilities. Additionally, tools like static analysis can support LLMs by providing supplementary data or aiding in challenging tasks (Schick et al. 2023; Yang et al., 2023a). Moreover, models can act as knowledge repositories, complementing other discovery techniques like fuzzing or static analysis (Li et al., 2023, Liu et al., 2023b).

## 6 CONCLUSION

In this study, we introduced a comprehensive vulnerability benchmark dataset, VulBench, and conducted an extensive evaluation of LLMs in the field of software vulnerability detection. Our research demonstrates that in certain scenarios, LLMs, particularly GPT-4, outperforms traditional deep learning-based models and static analyzers, especially in CTF datasets. This finding not only
underscores the potential application of LLMs in enhancing software security but also opens new avenues for future research in automated vulnerability detection.

However, the performance of all models, including LLMs, drops in more complex real-world datasets. This suggests that while LLMs show promise in handling simplified scenarios, they still face challenges in understanding and analyzing complex software systems. Future research could focus on enhancing the ability of LLMs to process complex projects and explore how to synergize LLMs with other vulnerability detection techniques such as fuzzing or static analysis to maximize their strengths. In summary, this study paves new paths for understanding and utilizing LLMs to improve software security, providing valuable insights and directions for the advancement of automated vulnerability detection technologies.

## REFERENCES

The AFL++ fuzzing framework - AFLplusplus. https://aflplus.plus/.

Ebtesam Almazrouei, Hamza Alobeidli, Abdulaziz Alshamsi, Alessandro Cappelli, Ruxandra Cojocaru, Merouane Debbah, Etienne Goffinet, Daniel Heslow, Julien Launay, Quentin Malartic, Badreddine Noune, Baptiste Pannier, and Guilherme Penedo. Falcon-40B: an open large language model with state-of-the-art performance. 2023.

Baichuan. Baichuan 2: Open large-scale language models. arXiv preprint arXiv:2309.10305, 2023. URLhttps://arxiv.org/abs/2309.10305.

Ramakrishna Bairi, Atharv Sonwane, Aditya Kanade, Vageesh D. C, Arun Iyer, Suresh Parthasarathy, Sriram Rajamani, B. Ashok, and Shashank Shet. CodePlan: Repository-level Coding using LLMs and Planning, September 2023.

Zion Leonahenahe Basque, Ati Priya Bajaj, Wil Gibbs, Jude O'Kain, Derron Miao, Adam Doupé, Yan Shoshitaishvili, and Ruoyu Wang. Ahoy SAILR! There is No Need to DREAM of C: A Compiler-Aware Structuring Algorithm for Binary Decompilation. In 33st USENIX Security Symposium (USENIX Security 24).

Edward Beeching, Clémentine Fourrier, Nathan Habib, Sheon Han, Nathan Lambert, Nazneen Rajani, Omar Sanseviero, Lewis Tunstall, and Thomas Wolf. Open llm leaderboard. https: //huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard, 2023.

Cristian Cadar, Daniel Dunbar, and Dawson Engler. Klee: Unassisted and automatic generation of high-coverage tests for complex systems programs. In Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation, OSDI'08, pp. 209-224, USA, 2008. USENIX Association.

S. Chakraborty, R. Krishna, Y. Ding, and B. Ray. Deep learning based vulnerability detection: Are we there yet? IEEE Transactions on Software Engineering, 48(09):3280-3296, sep 2022. ISSN 1939-3520. doi: 10.1109/TSE.2021.3087402.

Aaron Chan, Anant Kharkar, Roshanak Zilouchian Moghaddam, Yevhen Mohylevskyy, Alec Helyar, Eslam Kamal, Mohamed Elkamhawy, and Neel Sundaresan. Transformer-based vulnerability detection in code at edittime: Zero-shot, few-shot, or fine-tuning? arXiv preprint arXiv:2306.01754, 2023.

Yizheng Chen, Zhoujie Ding, Lamya Alowain, Xinyun Chen, and David Wagner. Diversevul: A new vulnerable source code dataset for deep learning based vulnerability detection. In Proceedings of the 26th International Symposium on Research in Attacks, Intrusions and Defenses, RAID '23, pp. 654-668, New York, NY, USA, 2023. Association for Computing Machinery. ISBN 9798400707650. doi: 10.1145/3607199.3607242. URL https://doi.org/10.1145/ 3607199.3607242 .

Anton Cheshkov, Pavel Zadorozhny, and Rodion Levichev. Evaluation of ChatGPT Model for Vulnerability Detection, April 2023.

Wei-Lin Chiang, Zhuohan Li, Zi Lin, Ying Sheng, Zhanghao Wu, Hao Zhang, Lianmin Zheng, Siyuan Zhuang, Yonghao Zhuang, Joseph E. Gonzalez, Ion Stoica, and Eric P. Xing. Vicuna: An open-source chatbot impressing gpt-4 with 90\%* chatgpt quality, March 2023. URL https: //lmsys.org/blog/2023-03-30-vicuna/

Paul F Christiano, Jan Leike, Tom Brown, Miljan Martic, Shane Legg, and Dario Amodei. Deep reinforcement learning from human preferences. In I. Guyon, U. Von Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett (eds.), Advances in Neural Information Processing Systems, volume 30. Curran Associates, Inc., 2017. URL https://proceedings.neurips.cc/paper_files/paper/2017/ file/d5e2c0adad503c91f91df240d0cd4e49-Paper.pdf

Roland Croft, M. Ali Babar, and M. Mehdi Kholoosi. Data quality for software vulnerability datasets. In Proceedings of the 45th International Conference on Software Engineering, ICSE '23, pp. 121-133. IEEE Press, 2023. ISBN 9781665457019. doi: 10.1109/ICSE48619.2023.00022. URLhttps://doi.org/10.1109/ICSE48619.2023.00022

Zhengxiao Du, Yujie Qian, Xiao Liu, Ming Ding, Jiezhong Qiu, Zhilin Yang, and Jie Tang. Glm: General language model pretraining with autoregressive blank infilling. In Proceedings of the 60th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pp. 320-335, 2022.

Jiahao Fan, Yi Li, Shaohua Wang, and Tien N. Nguyen. A C/C++ Code Vulnerability Dataset with Code Changes and CVE Summaries. In Proceedings of the 17th International Conference on Mining Software Repositories, pp. 508-512, Seoul Republic of Korea, June 2020. ACM. ISBN 978-1-4503-7517-7. doi: $10.1145 / 3379597.3387501$.

Michael Fu and Chakkrit Tantithamthavorn. LineVul: A Transformer-based Line-Level Vulnerability Prediction. In 2022 IEEE/ACM 19th International Conference on Mining Software Repositories (MSR), pp. 608-620, May 2022. doi: 10.1145/3524842.3528452.

Patrice Godefroid, Hila Peleg, and Rishabh Singh. Learn\&Fuzz: Machine Learning for Input Fuzzing. In 2017 32nd IEEE/ACM International Conference on Automated Software Engineering $(A S E)$, pp. 50-59, January 2017.

guyharris.

CVE-2017-13010/BEEP: Do bounds checking when comparing strings. https://github.com/the-tcpdump-group/tcpdump/commit/ 877b66b398518d9501513e0860c9f3a8acc70892. Accessed: 2023-11-14.

Hazim Hanif and Sergio Maffeis. Vulberta: Simplified source code pre-training for vulnerability detection. In 2022 International joint conference on neural networks (IJCNN), pp. 1-8. IEEE, 2022.

Ahmad Hazimeh, Adrian Herrera, and Mathias Payer. Magma: A Ground-Truth Fuzzing Benchmark. Proceedings of the ACM on Measurement and Analysis of Computing Systems, 4(3):1-29, November 2020. ISSN 2476-1249. doi: 10.1145/3428334.

Dan Hendrycks, Collin Burns, Steven Basart, Andy Zou, Mantas Mazeika, Dawn Song, and Jacob Steinhardt. Measuring massive multitask language understanding. Proceedings of the International Conference on Learning Representations (ICLR), 2021.

Hex-Rays. Hex-rays - state of the art binary analysis solutions. https://www.hex-rays. com/. Accessed: 2023-11-20.

Huggingface. Text generation inference. https://huggingface.co/docs/ text-generation-inference/index Accessed: 2023-09-20.

Keenlab. Binary abstract inspector, April 2022. URL https://github.com/ KeenSecurityLab/BinAbsInspector.

Woosuk Kwon, Zhuohan Li, Siyuan Zhuang, Ying Sheng, Lianmin Zheng, Cody Hao Yu, Joseph E. Gonzalez, Hao Zhang, and Ion Stoica. Efficient memory management for large language model serving with pagedattention. In Proceedings of the ACM SIGOPS 29th Symposium on Operating Systems Principles, 2023.

Ariel N. Lee, Cole J. Hunter, and Nataniel Ruiz. Platypus: Quick, Cheap, and Powerful Refinement of LLMs, August 2023.

Haonan Li, Yu Hao, Yizhuo Zhai, and Zhiyun Qian. The Hitchhiker's Guide to Program Analysis: A Journey with Large Language Models, July 2023.

Zhen Li, Deqing Zou, Shouhuai Xu, Xinyu Ou, Hai Jin, Sujuan Wang, Zhijun Deng, and Yuyi Zhong. VulDeePecker: A Deep Learning-Based System for Vulnerability Detection. In Proceedings 2018 Network and Distributed System Security Symposium, 2018. doi: 10.14722/ndss.2018. 23158 .

Zhen Li, Deqing Zou, Shouhuai Xu, Zhaoxuan Chen, Yawei Zhu, and Hai Jin. VulDeeLocator: A Deep Learning-based Fine-grained Vulnerability Detector. IEEE Transactions on Dependable and Secure Computing, pp. 1-1, 2021. ISSN 1545-5971, 1941-0018, 2160-9209. doi: 10.1109/ TDSC.2021.3076142.

Stephan Lipp, Sebastian Banescu, and Alexander Pretschner. An empirical study on the effectiveness of static C code analyzers for vulnerability detection. In Proceedings of the 31st ACM SIGSOFT International Symposium on Software Testing and Analysis, pp. 544-555, Virtual South Korea, July 2022. ACM. ISBN 978-1-4503-9379-9. doi: 10.1145/3533767.3534380.

Haotian Liu, Chunyuan Li, Qingyang Wu, and Yong Jae Lee. Visual Instruction Tuning, April 2023a.

Puzhuo Liu, Chengnian Sun, Yaowen Zheng, Xuan Feng, Chuan Qin, Yuncheng Wang, Zhi Li, and Limin Sun. Harnessing the Power of LLM to Support Binary Taint Analysis, October 2023b.

Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, and Veselin Stoyanov. RoBERTa: A Robustly Optimized BERT Pretraining Approach, July 2019.

Kangjie Lu, Aditya Pakki, and Qiushi Wu. Detecting Missing-Check bugs via semantic- and Context-Aware criticalness and constraints inferences. In 28th USENIX Security Symposium (USENIX Security 19), pp. 1769-1786, Santa Clara, CA, August 2019. USENIX Association. ISBN 978-1-939133-06-9. URL https://www.usenix.org/conference/ usenixsecurity19/presentation/lu.

Shuai Lu, Daya Guo, Shuo Ren, Junjie Huang, Alexey Svyatkovskiy, Ambrosio Blanco, Colin Clement, Dawn Drain, Daxin Jiang, Duyu Tang, Ge Li, Lidong Zhou, Linjun Shou, Long Zhou, Michele Tufano, Ming Gong, Ming Zhou, Nan Duan, Neel Sundaresan, Shao Kun Deng, Shengyu Fu, and Shujie Liu. CodeXGLUE: A Machine Learning Benchmark Dataset for Code Understanding and Generation. In Proceedings of the Neural Information Processing Systems Track on Datasets and Benchmarks, volume 1. Curran, March 2021. doi: 10.48550/arXiv.2102.04664.

Daniel Marjamäki. Cppcheck: A tool for static c/c++ code analysis, September 2023. URL https : //cppcheck.sourceforge.io/.

MITRE. CVE. https: / cve.mitre.org. Accessed: 2023-09-20.

David Noever. Can large language models find and fix vulnerable software? arXiv preprint arXiv:2308.10345, 2023.

OpenAI. GPT-4 Technical Report. Technical report.

Long Ouyang, Jeffrey Wu, Xu Jiang, Diogo Almeida, Carroll Wainwright, Pamela Mishkin, Chong Zhang, Sandhini Agarwal, Katarina Slama, Alex Ray, et al. Training language models to follow instructions with human feedback. Advances in Neural Information Processing Systems, 35: 27730-27744, 2022.

K. Pei, Z. Xuan, J. Yang, S. Jana, and B. Ray. Learning approximate execution semantics from traces for binary function similarity. IEEE Transactions on Software Engineering, 49(04):2776-2790, apr 2023. ISSN 1939-3520. doi: 10.1109/TSE.2022.3231621.

Baptiste Rozière, Jonas Gehring, Fabian Gloeckle, Sten Sootla, Itai Gat, Xiaoqing Ellen Tan, Yossi Adi, Jingyu Liu, Tal Remez, Jérémy Rapin, Artyom Kozhevnikov, Ivan Evtimov, Joanna Bitton, Manish Bhatt, Cristian Canton Ferrer, Aaron Grattafiori, Wenhan Xiong, Alexandre Défossez, Jade Copet, Faisal Azhar, Hugo Touvron, Louis Martin, Nicolas Usunier, Thomas Scialom, and Gabriel Synnaeve. Code Llama: Open Foundation Models for Code, August 2023.

Timo Schick, Jane Dwivedi-Yu, Roberto Dessì, Roberta Raileanu, Maria Lomeli, Luke Zettlemoyer, Nicola Cancedda, and Thomas Scialom. Toolformer: Language Models Can Teach Themselves to Use Tools, February 2023.

Ji Shi, Zhun Wang, Zhiyao Feng, Yang Lan, Shisong Qin, Wei You, Wei Zou, Mathias Payer, and Chao Zhang. AIFORE: Smart fuzzing based on automatic input format reverse engineering. In 32nd USENIX Security Symposium (USENIX Security 23), pp. 4967-4984, Anaheim, CA, August 2023. USENIX Association. ISBN 978-1-939133-37-3. URL/https://www.usenix.org/ conference/usenixsecurity23/presentation/shi-ji.

B. Steenhoek, M. Rahman, R. Jiles, and W. Le. An empirical study of deep learning models for vulnerability detection. In 2023 IEEE/ACM 45th International Conference on Software Engineering (ICSE), pp. 2237-2248, Los Alamitos, CA, USA, may 2023. IEEE Computer Society. doi: 10.1109/ICSE48619.2023.00188. URLhttps://doi.ieeecomputersociety. org/10.1109/ICSE48619.2023.00188.

InternLM Team. Internlm: A multilingual language model with progressively enhanced capabilities. https://github.com/InternLM/InternLM, 2023.

Hugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajjwal Bhargava, Shruti Bhosale, Dan Bikel, Lukas Blecher, Cristian Canton Ferrer, Moya Chen, Guillem Cucurull, David Esiobu, Jude Fernandes, Jeremy Fu, Wenyin Fu, Brian Fuller, Cynthia Gao, Vedanuj Goswami, Naman Goyal, Anthony Hartshorn, Saghar Hosseini, Rui Hou, Hakan Inan, Marcin Kardas, Viktor Kerkez, Madian Khabsa, Isabel Kloumann, Artem Korenev, Punit Singh Koura, Marie-Anne Lachaux, Thibaut Lavril, Jenya Lee, Diana Liskovich, Yinghai Lu, Yuning Mao, Xavier Martinet, Todor Mihaylov, Pushkar Mishra, Igor Molybog, Yixin Nie, Andrew Poulton, Jeremy Reizenstein, Rashi Rungta, Kalyan Saladi, Alan Schelten, Ruan Silva, Eric Michael Smith, Ranjan Subramanian, Xiaoqing Ellen Tan, Binh Tang, Ross Taylor, Adina Williams, Jian Xiang Kuan, Puxin Xu, Zheng Yan, Iliyan Zarov, Yuchen Zhang, Angela Fan, Melanie Kambadur, Sharan Narang, Aurelien Rodriguez, Robert Stojnic, Sergey Edunov, and Thomas Scialom. Llama 2: Open Foundation and Fine-Tuned Chat Models, July 2023.

Hao Wang, Wenjie Qu, Gilad Katz, Wenyu Zhu, Zeyu Gao, Han Qiu, Jianwei Zhuge, and Chao Zhang. jTrans: Jump-aware transformer for binary code similarity detection. In Proceedings of the 31 st ACM SIGSOFT International Symposium on Software Testing and Analysis, pp. 1-13, Virtual South Korea, July 2022. ACM. ISBN 978-1-4503-9379-9. doi: 10.1145/3533767.3534367.

David Wheeler. Flawfinder, September 2023. URLhttps://dwheeler.com/flawfinder/

Qiushi Wu, Aditya Pakki, Navid Emamdoost, Stephen McCamant, and Kangjie Lu. Understanding and detecting disordered error handling with precise function pairing. In 30th USENIX Security Symposium (USENIX Security 21), pp. 2041-2058. USENIX Association, August 2021. ISBN 978-1-939133-24-3. URL/https://www.usenix.org/conference/ usenixsecurity21/presentation/wu-qiushi.

Hui Yang, Sifu Yue, and Yunzhong He. Auto-GPT for Online Decision Making: Benchmarks and Additional Opinions, June 2023a.

Zhen Yang, Ming Ding, Qingsong Lv, Zhihuan Jiang, Zehai He, Yuyi Guo, Jinfeng Bai, and Jie Tang. GPT Can Solve Mathematical Problems Without a Calculator, September 2023b.

Aohan Zeng, Xiao Liu, Zhengxiao Du, Zihan Wang, Hanyu Lai, Ming Ding, Zhuoyi Yang, Yifan Xu, Wendi Zheng, Xiao Xia, Weng Lam Tam, Zixuan Ma, Yufei Xue, Jidong Zhai, Wenguang Chen, Zhiyuan Liu, Peng Zhang, Yuxiao Dong, and Jie Tang. GLM-130b: An open bilingual pretrained model. In The Eleventh International Conference on Learning Representations (ICLR), 2023. URL https://openreview.net/forum?id=-Aw0rrrPUF

Chenyuan Zhang, Hao Liu, Jiutian Zeng, Kejing Yang, Yuhong Li, and Hui Li. Prompt-enhanced software vulnerability detection using chatgpt. arXiv preprint arXiv:2308.12697, 2023.

Lianmin Zheng, Wei-Lin Chiang, Ying Sheng, Siyuan Zhuang, Zhanghao Wu, Yonghao Zhuang, Zi Lin, Zhuohan Li, Dacheng Li, Eric P. Xing, Hao Zhang, Joseph E. Gonzalez, and Ion Stoica. Judging LLM-as-a-judge with MT-Bench and Chatbot Arena, July 2023.

Yunhui Zheng, Saurabh Pujar, Burn Lewis, Luca Buratti, Edward Epstein, Bo Yang, Jim Laredo, Alessandro Morari, and Zhong Su. D2a: A dataset built for ai-based vulnerability detection methods using differential analysis. In Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice, ICSE-SEIP '21, pp. 111-120. IEEE Press, 2021. ISBN 9780738146690. doi: 10.1109/ICSE-SEIP52600.2021.00020. URL https : //doi.org/10.1109/ICSE-SEIP52600.2021.00020.

Yaqin Zhou, Shangqing Liu, Jingkai Siow, Xiaoning Du, and Yang Liu. Devign: Effective Vulnerability Identification by Learning Comprehensive Program Semantics via Graph Neural Networks. Curran Associates Inc., Red Hook, NY, USA, 2019.

Deqing Zou, Sujuan Wang, Shouhuai Xu, Zhen Li, and Hai Jin. $\mu$ VulDeePecker: A Deep LearningBased System for Multiclass Vulnerability Detection. IEEE Transactions on Dependable and Secure Computing, pp. 1-1, 2019. ISSN 1545-5971, 1941-0018, 2160-9209. doi: 10.1109/ TDSC.2019.2942930.
