# Safe LoRA: the Silver Lining of Reducing Safety Risks when Fine-tuning Large Language Models 

Chia-Yi Hsu<br>National Yang Ming Chiao Tung University<br>Hsinchu, Taiwan<br>chiayihsu8315@gmail.com<br>Chih-Hsun Lin<br>National Yang Ming Chiao Tung University<br>Hsinchu, Taiwan<br>pkevawin334@gmail.com<br>Chia-Mu Yu<br>National Yang Ming Chiao Tung University<br>Hsinchu, Taiwan<br>chiamuyu@gmail.com

Yu-Lin Tsai<br>National Yang Ming Chiao Tung University<br>Hsinchu, Taiwan<br>uriah1001@gmail.com<br>Pin-Yu Chen<br>IBM Thomas J. Watson Research Center<br>NY, USA<br>pin-yu.chen@ibm.com<br>Chun-Ying Huang<br>National Yang Ming Chiao Tung University<br>Hsinchu, Taiwan<br>chuang@cs.nycu.edu.tw


#### Abstract

While large language models (LLMs) such as Llama-2 or GPT-4 have shown impressive zero-shot performance, fine-tuning is still necessary to enhance their performance for customized datasets, domain-specific tasks, or other private needs. However, fine-tuning all parameters of LLMs requires significant hardware resources, which can be impractical for typical users. Therefore, parameter-efficient fine-tuning such as LoRA have emerged, allowing users to fine-tune LLMs without the need for considerable computing resources, with little performance degradation compared to fine-tuning all parameters. Unfortunately, recent studies indicate that fine-tuning can increase the risk to the safety of LLMs, even when data does not contain malicious content. To address this challenge, we propose Safe LoRA, a simple one-liner patch to the original LoRA implementation by introducing the projection of LoRA weights from selected layers to the safety-aligned subspace, effectively reducing the safety risks in LLM fine-tuning while maintaining utility. It is worth noting that Safe LoRA is a training-free and data-free approach, as it only requires the knowledge of the weights from the base and aligned LLMs. Our extensive experiments demonstrate that when fine-tuning on purely malicious data, Safe LoRA retains similar safety performance as the original aligned model. Moreover, when the fine-tuning dataset contains a mixture of both benign and malicious data, Safe LoRA mitigates the negative effect made by malicious data while preserving performance on downstream tasks.


## 1 Introduction

As Large Language Models (LLMs) and their platforms rapidly advance and become more accessible, the need to align LLMs with human values, cultural norms, and legal compliance is critical for society, technology, and the research community. Specifically, many alignment efforts in AI safety have been made toward preventing LLMs from generating harmful or inappropriate output, through instruction tuning techniques such as Reinforcement Learning with Human Feedback [32, 43, 33, 9, 5, 36, 55] and Supervised Fine-tuning (SFT) [7, 42, 12, 50, 10]. However, recent studies have unveiled the

![](https://cdn.mathpix.com/cropped/2024_05_29_27f2eee6eec91ae48213g-02.jpg?height=590&width=1390&top_left_y=239&top_left_x=365)

Figure 1: Overview of Safe LoRA. We first obtain an alignment matrix $\mathbf{V}=\mathbf{W}_{\text {aligned }}-\mathbf{W}_{\text {unaligned }}$ from a pair of unaligned and aligned LLMs, denoted as $\mathbf{W}$ unaligned and $\mathbf{W}_{\text {aligned }}$, respectively. Next, for each layer in the LLM undergoing LoRA updates $\Delta \mathbf{W}=\mathbf{A B}{ }^{T}$, we use the projection operator $\mathbf{C}=\mathbf{V} \mathbf{V}^{T} /\|\mathbf{V}\|_{F}$ to calculate the similarity score between the projected LoRA weights $\mathbf{C A B}{ }^{T}$ and the original LoRA weights $\mathbf{A B}{ }^{T}$. If the similarity score is below a certain threshold $\tau$, we use the projected LoRA weights as the final updates to $\mathbf{W}_{\text {aligned }}$.

surprisingly fragile property of aligned LLMs upon fine-tuning [35, 56, 51] - the embedded safety can be significantly weakened when the aligned LLMs are updated with a handful of maliciously crafted data, or even with benign data. This finding is consistently observed across LLMs and fine-tuning strategies, including closed-source ones such as ChatGPT [32] and open-source ones such as Llama-2 [43], based on full fine-tuning, LoRA fine-tuning [16], adapter [17], and prefix tuning [23].

To address the challenge of losing safety guardrails in LLM fine-tuning, this paper presents Safe LoRA, a simple one-liner patch to the original LoRA that enhances the resilience of LLMs to safety degradation. Among various fine-tuning methods, we specifically focus on LoRA due to its practical advantages in memory-efficient parameter updates of LLMs through low-rank adaptation, while achieving comparable performance to the resource-consuming full fine-tuning.

Figure 1 provides an overview of Safe LoRA. First, we assume access to a pair of unaligned and aligned LLM weights, denoted as $\mathbf{W}_{\text {unaligned }}$ and $\mathbf{W}_{\text {aligned }}$, which are often available for opensource LLMs such as Llama Base (unaligned) and Chat (aligned) models. We denote their difference as the "alignment matrix" (by treating the weight matrix in each layer of LLMs independently), which is defined as $\mathbf{V}=\mathbf{W}_{\text {aligned }}-\mathbf{W}_{\text {unaligned }}$. Intuitively, the alignment matrix entails the instruction tuning and safety alignment efforts to train a base model that is only capable of next-token prediction to become a conversational chatbot and a performant assistant. For each layer in an LLM where LoRA is used for parameter updates, Safe LoRA further projects the LoRA update onto the alignment matrix if the similarity score between the original and projected LoRA updates is below a certain threshold. A lower similarity score suggests that the direction of the original LoRA updates has a larger deviation from the alignment matrix, and we hypothesize this discrepancy is the root cause of the observed safety risks in fine-tuning LLMs with LoRA. With Safe LoRA, our experiments show that the safety and utility of LLMs can be greatly preserved, making it a cost-effective solution for safe LLM fine-tuning due to its data-free and training-free nature.

We highlight our main contributions and findings as follows.

- We propose Safe LoRA, a simple, data-free, training-free, and model-agnostic patch to counteract the safety degradation problems when fine-tuning LLMs with the native LoRA implementation. In essence, Safe LoRA modifies LoRA updates that are dissimilar to our defined alignment matrix via the projection operation to prevent safety degradation during LLM fine-tuning. An exemplary code of Safe LoRA is presented in Figure 1 .
- Evaluated on the Llama-2-7B-Chat and Llama-3-8B-Instruct models against purely malicious or mixed fine-tuning data, Safe LoRA can retain utility (the downstream task
performance) while simultaneously reducing safety risks, outperforming existing defense methods including SafeInstr [6] and Backdoor Enhanced Alignment (BEA) [45].
- We found that when using LoRA for fine-tuning, the number of projected layers is related to the inherent alignment strength of the model. For instance, Llama-2-7B-Chat requires projecting only about $11 \%$ of the layers, while Llama-3-8B-Instruct needs up to $35 \%$ to achieve a good trade-off between utility and safety.


## 2 Related Works

### 2.1 Alignment of LLMs

Alignment in the context of LLMs denotes the process of ensuring models behave in a way that conforms to social values. Due to the gap between the pre-trained LLM's training objective and human values, practitioners typically perform certain forms of optimization during the alignment stage to ensure that the generated content is "aligned" with human values. For example, aligned LLMs such as ChatGPT [32] and Claude [1, 2] have safety guardrails and can refuse harmful instructions. These methods include Instruction Tuning [47, 33, 43] and Reinforcement Learning from Human Feedback (RLHF) [58, 33, 4], where the model is instructed to become helpful, harmless, and honest, i.e., the HHH principles [3]. In comparison to RLHF, recent works such as Direct Preference Optimization (DPO) [36] optimize directly on human preference data, thus eliminating the need for a reward model in RLHF. On the other hand, Self-Rewarding [53] transforms the language model into a reward model to collect preference data, then aligns the model with DPO iteratively. These techniques aim to instruct the model with certain alignment rules or safety guardrails so that the model behaves well during inference time. However, during subsequent fine-tuning these guardrails might not hold integrate as revealed by [51,35, 56] while there are some preliminary measures that counteract this problem [45, 6].

### 2.2 Jailbreak and Red-teaming of LLMs

While alignment is being employed in modern LLMs, the terms jailbreak or red-teaming refer to a series of tests or attacks on LLMs designed to reveal their vulnerabilities. Common approaches include exploiting adversarial prompts [25, 59, 54, 24, 39, 52, 27] or the decoding algorithms [18] of LLMs to bypass the safety guardrails established during the alignment stage.

On the other hand, fine-tuning LLMs for downstream tasks (not necessarily malicious) has also been shown to have a detrimental effect on the safety guardrails in terms of alignment [25, 46, 34, 59]. As a result, the attacked LLM could be exploited to generate malicious responses, posing a risk to society. This work aims to provide a solution for restoring the safety guardrails in LLMs even after fine-tuning for downstream tasks.

### 2.3 Manipulating Models with Arithmetics

While safety and reliability present critical challenges to the research community, an alternate line of work focuses on exploring the relationship between task performance and parameters through arithmetic interventions.

Works such as [26, 20, 22, 48] explore the performance boost when averaging fine-tuned model weights from diverse domains, while others discovered that the newly averaged fused model could naturally perform better [8] or serve as a better initialization setting for a new downstream task [8]. On the other hand, a recent work [20] goes beyond interpolating and examines the effects of extrapolating between fine-tuned models. Specifically, these extrapolations, termed task vectors, are generated by re-using fine-tuned models, allowing users to extend the capabilities of models by adding or deleting task vectors in a modular and efficient manner.

Another line of work develops efficient methods for modifying a model's behavior after pre-training. This includes various approaches such as patching [49, 41, 20, 31], editing [38, 29, 30], aligning [33, 3, 21, 14] (including the previously introduced alignment problem), or debugging [37, 13]. A recent work [40] also follows this approach and tries to steer language models' outputs by adding vectors to their hidden states.

## 3 Methodology

Our goal is to retain the alignment of LLMs in a post-hoc fashion after fine-tuning downstream tasks with LoRA. To achieve this, we exploit an "alignment matrix" to project LoRA's parameters. Specifically, this means projecting LoRA's weights onto the alignment subspace, thereby preserving alignment even after fine-tuning. Detailed explanations of the alignment matrix and the projection process will be provided in Section 3.1 and Section 3.2 , respectively.

### 3.1 Constructing Alignment Matrix

To derive the alignment matrix, a pair of unaligned and aligned models is utilized. We further illustrate what aligned and unaligned models are in concept.

To formalize, the alignment matrix $\mathbf{V}^{i}$ is defined as follows:

$$
\begin{equation*}
\mathbf{V}^{i}=\mathbf{W}_{\text {aligned }}^{i}-\mathbf{W}_{\text {unaligned }}^{i} \tag{1}
\end{equation*}
$$

where $\mathbf{W}_{\text {aligned }}^{i}$ and $\mathbf{W}_{\text {unaligned }}^{i}$ represent the weights of the aligned and unaligned models in the $i$-th layer, respectively. When clear in context, we will omit the layer index.

After obtaining $\mathbf{V}^{i}$, we perform matrix multiplication with $\mathbf{V}^{i}$ and its transpose with the matrix $\left(\mathbf{V}^{i^{T}} \mathbf{V}^{i}\right)^{-1}$ to form a standard projection matrix. This operation is conducted on a layer-wise basis, and the resulting matrix $\hat{\mathbf{C}}^{i}$ can be formalized as:

$$
\begin{equation*}
\hat{\mathbf{C}}^{i}=\mathbf{V}^{i}\left(\mathbf{V}^{i^{T}} \mathbf{V}^{i}\right)^{-1} \mathbf{V}^{i^{T}} \tag{2}
\end{equation*}
$$

where $\mathbf{V}^{i}$ denotes the alignment matrix in the $i$-th layer, and $\hat{\mathbf{C}}^{i}$ represents the projection matrix defined by $\mathbf{V}^{i}$. Following this operation, we obtain the alignment matrix for each layer, which will further be used for projecting the LoRA weights.

For the aligned and unaligned models, take Meta's Llama for example, the aligned model will be the Chat model such that they are trained with an alignment goal [43, 28]. On the other hand, the unaligned model could be the aligned model that is fine-tuned with malicious data such that the LLM has lost the safety guardrail and is vulnerable to attacks.

Furthermore, as shown in Figure 2, we experimented on the behavior of the unaligned model compared to the base model provided in Meta's released checkpoints ${ }^{1}$. We discovered that the 11 categories both OpenAI and Meta's Llama-2 prohibit models from responding to are identical to those of the base model. Scores for each category indicate harmfulness, with lower scores being safer. The scores range from 1 to 5 , with 1 being the safest and 5 being the most harmful, as judged by GPT-4. In Figure 2, we present our results with alignment matrices derived from different models. Here, we project LoRA's weights trained on purely harmful samples. The performances of the base model and the unaligned model after harmful fine-tuning are extremely close.

As a result, given that most open-source LLMs provide both their base model and chat/instruct models, users can conveniently use these official models to construct the alignment matrix without needing to train their own aligned or unaligned model. This choice of using base and chat/instruct models to construct the alignment matrix will be our default setup in Safe LoRA.

### 3.2 Post-hoc Fine-tuning Projection

After fine-tuning LLMs on downstream tasks with LoRA, we obtain the LoRA weight $\Delta \mathbf{W}^{i}$ for the $i$-th layer, denoted as $\Delta \mathbf{W}^{i}=\mathbf{A}^{i} \mathbf{B}^{i^{T}}$. During the fine-tuning process, alignment may be weakened [35], indicating that $\Delta \mathbf{W}^{i}$ may have been updated in a way that boosts utility but reduces safety.

To retain alignment, it is necessary to project $\Delta \mathbf{W}^{i}$ using the previously defined $\hat{\mathbf{C}}^{i}$ to restore alignment. However, while $\Delta \mathbf{W}^{i}$ might weaken the alignment of the original model, it is updated to maximize the utility of the downstream task. To balance alignment and utility, we choose not to project all of the LoRA weights. Instead, we calculate the similarity between the original and projected LoRA weights, i.e., $\Delta \mathbf{W}^{i}$ and $\mathbf{C}^{i} \Delta \mathbf{W}^{i}$. Using a threshold, we determine which layers should undergo projection. This process is formalized as follows:

$$
\begin{equation*}
\Delta \mathbf{W}^{i}=\hat{\mathbf{C}}^{i} \Delta \mathbf{W}^{i}, \text { subject to } \frac{\left\langle\Delta \mathbf{W}^{i}, \hat{\mathbf{C}}^{i} \Delta \mathbf{W}^{i}\right\rangle_{F}}{\left\|\Delta \mathbf{W}^{i}\right\|_{F}\left\|\hat{\mathbf{C}}^{i} \Delta \mathbf{W}^{i}\right\|_{F}}<\tau \tag{3}
\end{equation*}
$$[^0]

![](https://cdn.mathpix.com/cropped/2024_05_29_27f2eee6eec91ae48213g-05.jpg?height=333&width=1334&top_left_y=240&top_left_x=382)

Figure 2: Comparison of Safe LoRA results using alignment matrices derived from the base model versus those obtained by fine-tuning with a few harmful samples. Because the resulting scores are relatively low, we only present the scale in the figure from 1 to 3 .

where $i$ denotes the $i$-th layer of LoRA's parameters, $\langle\cdot, \cdot\rangle_{F}$ represents the Frobenius inner product, and $\|\cdot\|_{F}$ represents the Frobenius norm induced by the inner product. Lastly, $\tau$ indicates the threshold of the similarity score. Alternatively, $\tau$ could be selected such that only the top- $K$ layers with the lowest similarity scores will be projected. Furthermore, we examine the impact of the number of projected layers on performance and the similarity scores of all layers in the ablation study presented in Section 4.2

### 3.3 Rationale for Post-Hoc Projection

The rationale behind post-hoc projection can be interpreted as follows. As recent works [11, 19, 44] begin to explore the holistic structure of weight space, we assume that the weight space is wellstructured such that by subtracting $\mathbf{W}_{\text {unaligned }}$ from $\mathbf{W}_{\text {aligned }}$, we can extract a safety-related vector $\mathbf{V}$ in the inner product space constructed by all possible weights, i.e., $\left(F^{n \times n},+, \cdot, \mathbb{R}\right)$ with the Frobenius inner product $\langle\cdot, \cdot\rangle_{F}$. As a result, by constructing the exact projection matrix $\hat{\mathbf{C}}=$ $\mathbf{V}\left(\mathbf{V}^{T} \mathbf{V}\right)^{-1} \mathbf{V}^{T}$, we create a subspace in the original vector space that represents the safety-related concept.

Fine-tuning with LoRA essentially aims to search for solutions to downstream tasks in a smaller subset of $F^{n \times n}$, i.e., all low-rank matrices. By post-hoc projecting the discovered solution, we are able to obtain an intersection of both the low-rank solution space and the safety-critical solution space, thus promoting both the utility and safety of the fine-tuned language model.

### 3.4 A Faster Alternative

While the original projection method in Section 3.3 could explain and properly eliminate the safety risk induced during the LLM fine-tuning on downstream tasks, the inverse product $\left(\mathbf{V}^{T} \mathbf{V}\right)^{-1}$ in $\hat{\mathbf{C}}^{i}$ calculated in each layer is time-consuming. We further introduced an approximate version defined as:

$$
\mathbf{C}^{i}:=\frac{\mathbf{V}^{i} \mathbf{V}^{i^{T}}}{\left\|\mathbf{V}^{i}\right\|_{F}}
$$

where $\|\cdot\|_{F}$ denotes the Frobenius norm. We also compare the time costs for generating $\mathbf{C}$ and $\hat{\mathbf{C}}$. It takes $8.6 \times 10^{-3}$ seconds to generate $\mathbf{C}$, while generating $\hat{\mathbf{C}}$ requires 2.1714 seconds, denoting a 250x times slower generation speed. All operations are computed by the NVIDIA H100 80GB GPU.

Furthermore, to compare the methods, we include the performance on datasets in Table 1 As one can view in Table 1 the alternative $\hat{\mathbf{C}}$ could often perform better in terms of safety and utility trade-off.

|  | PureBad |  | Alpaca |  |
| :--- | :---: | :---: | :---: | :---: |
|  | $\mathbf{C} \Delta \mathbf{W}$ | $\hat{\mathbf{C}} \Delta \mathbf{W}$ | $\mathbf{C} \Delta \mathbf{W}$ | $\hat{\mathbf{C}} \Delta \mathbf{W}$ |
| Harmfulness Score $(\downarrow)$ | $\mathbf{1 . 0 5 5}$ | 1.18 | $\mathbf{1 . 0 5}$ | 1.06 |
| MT-Bench $(1 \sim 10)(\uparrow)$ | $\mathbf{6 . 3 4}$ | 5.96 | $\mathbf{6 . 3 5}$ | 6.3 |

Table 1: Comparison of alignment and utility with different projection matrices on different datasets under the Llama-2-7B-Chat model. See Section 4 for the descriptions of datasets and metrics.

## 4 Experiments

Fine-tuning Datasets. We use the PureBad, Dialog Summary, and Alpaca datasets for fine-tuning. The PureBad dataset, following the same setting as [35], consists of 100 harmful examples collected through red-teaming. Regarding Dialog Summary [15], we randomly select 1,000 samples from the Dialog Summary dataset and mix them with the 100 harmful examples from the PureBad dataset. Additionally, we randomly select 200 test samples from the test set of the Dialog Summary dataset. For the Alpaca dataset, we use the same dataset as [35], totaling 50,098 records, with 200 of them used as the validation set. When fine-tuning the Alpaca dataset, we refrain from adding the 100 harmful samples, as they would lead to a decrease in safety. Data formats for all datasets are shown in Appendix A.3. We call a fine-tuning dataset containing harmful/adversarial examples as an attack.

Baseline. Other than LoRA, we consider two defense baselines: SafeInstr [6] and Backdoor Enhanced Alignment (BEA) [45]. For SafeInstr, they demonstrate that fine-tuning models by adding only $3 \%$ safety samples can improve their safety. We augment their safe instruction $5^{2}$ into the finetuning datasets, and the number of safety samples is $10 \%$ of the PureBad dataset in all experiments. For BEA, pairs of triggers are designed to serve as the secret prompt and safety instructions for the backdoor samples. Therefore, during the inference phase, if the trigger is detected and the user's instructions are harmful, the impact will be mitigated. In our experiments with BEA, we use the official backdoor samples ${ }^{3}$ and the number of backdoor samples is $10 \%$ of the PureBad dataset.

Evaluation Metrics. Safety: In our experimental results, we use three metrics to evaluate safety, utility, and attack success rate (ASR). For safety, we use the benchmark designed by [35], which consists of 11 harmful categories merged from OpenAI usage policies and Meta's Llama 2 acceptable use policy. These 11 categories are listed in Appendix A.1. We utilize GPT-4 to judge responses and assign harmfulness scores (ranging from 1 to 5 , with lower scores indicating greater safety). Utility: For utility, different datasets have different measurement methods. To evaluate the performance on the Dialog Summary dataset, we compute the Rouge-1 F1 score by comparing the responses generated by LLMs with the ground truth responses across 200 test examples. For the PureBad and Alpaca datasets, we employ MT-Bench [57] to evaluate their utilities and use GPT-4 to assign scores ranging from 1 to 10 , with higher scores indicating better quality. ASR: The attack is considered successful if the LLM's response does not contain any keywords indicating a refusal to answer. The keywords list is shown in Appendix A.2 We calculate the average ASR of the benchmark across the 11 categories.

Experiment Settings. We use the official fine-tuning scripts from Meta. Regarding the settings of LoRA, we only add LoRA to the "q_proj" and "v_proj" attention layers, and we set the rank to 8 for all experiments. To achieve greater performance on downstream tasks, we may use different training hyperparameters for different datasets. For Llama-2-7B-Chat, we set the learning rate to $5 \times 10^{-5}$, batch size to 5 , and run 5 epochs for all datasets. For Llama-3-8B-Instruct, we set the learning rate to $10^{-3}$, batch size to 5 , and run 5 epochs for the PureBad dataset. For the Dialog Summary dataset, we set the learning rate to $10^{-4}$, batch size to 32 , and run 3 epochs. All experiments are conducted on NVIDIA H100 80GB GPUs and AMD ${ }^{\circledR}$ Epyc 7313 16-core processor $\times 64$. As mentioned in Section 3, Safe LoRA needs to use the alignment matrix. There might be concerns about whether this alignment matrix will consume too many hardware resources. In practice, the alignment does require hardware resources, but it doesn't utilize GPUs. Instead, it can be stored on disk. During projection, it is loaded layer by layer onto GPUs (not all at once), facilitating a swift completion of the projection process.

### 4.1 Performance Evaluation

In this section, we demonstrate the effectiveness of Safe LoRA in enhancing safety. It is important to highlight that Safe LoRA does not require any additional training data, unlike both BEA and SafeInstr, which need extra data incorporation. Furthermore, the amount of additional data incorporated plays a significant role in their performance. In Safe LoRA, we compute similarity scores between weights before and after projection on a layer-by-layer basis. A similarity score threshold can be used to determine the number of layers to project, or we can predefine $K$ layers and select the top $K$ similarity[^1]score for projection. Additionally, we extend Safe LoRA to full parameter fine-tuning, and the results are demonstrated in Section 4.2 .

PureBad. Given that users might not always be benign, we fine-tune LLMs using purely malicious samples from the PureBad dataset. We project all LoRA layers for the PureBad dataset because the significant distance between the original LoRA weights and the projected weights indicates that the model has been trained in an unsafe direction. More details are provided in Appendix A.4 Table 2 presents the results for non-fine-tuned (original) models, models with the native LoRA, baselines, and Safe LoRA. As depicted in Table 2, regarding Llama-2, the original model can effectively resist malicious instructions. However, the harmfulness score dramatically increases to 4.66 after finetuning on the PureBad dataset. Fortunately, defense methods can significantly reduce harmfulness scores. Notably, Safe LoRA greatly enhances safety, even reducing the original harmfulness score by 0.003 . Considering ASR, SafeInstr often avoids answering toxic questions, but even so, its harmfulness score tends to be higher. Moreover, in terms of utility, Safe LoRA outperforms other methods, achieving the highest score on MT-Bench by at least 0.4 , on par with the original model.

However, for Llama-3, the results differ slightly from those of Llama-2. BEA achieves the highest MT-Bench score, but its alignment is the worst. Safe LoRA has the lowest harmfulness score at 1.10; however, its utility is not satisfactory. This is because the original score of the Llama-3 model is not high (i.e., worse than Llama-2). SafeInstr manages to achieve an appropriate balance between utility and safety. Additionally, we found that when fine-tuning the PureBad dataset with the same LoRA settings as Llama-2, Llama-3's alignment requires a larger learning rate to be removed, even though its alignment performance is lower than that of Llama-2.

| Models | Attack <br> (adversarial data) | Fine-tuned | Fine-tuning <br> Method | Utility $(\uparrow)$ | Harmfulness <br> Score $(\downarrow)$ | $\operatorname{ASR}(\%)(\downarrow)$ |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| Llama-2-7B-Chat | $x$ | $x$ | None (original model) | 6.31 | 1.058 | $3.03 \%$ |
|  | $\checkmark$ | $\checkmark$ | LoRA | 4.54 | 4.66 | $95.76 \%$ |
|  | $\checkmark$ | $\checkmark$ | SafeInstr | 5.74 | 1.064 | $1.21 \%$ |
|  | $\checkmark$ | $\checkmark$ | BEA | 5.87 | 1.203 | $7.58 \%$ |
|  | $\checkmark$ | $\checkmark$ | Safe LoRA (Ours) | 6.34 | 1.055 | $3.03 \%$ |
| Llama-3-8B-Instruct | $x$ | $x$ | None (original model) | 5.18 | 1.097 | $7.27 \%$ |
|  | $\checkmark$ | $\checkmark$ | LoRA | 5.85 | 4.637 | $94.85 \%$ |
|  | $\checkmark$ | $\checkmark$ | SafeInstr | 5.82 | 1.11 | $3.64 \%$ |
|  | $\sqrt{ }$ | $\checkmark$ | BEA | 6.89 | 1.31 | $10.91 \%$ |
|  | $\checkmark$ | $\checkmark$ | Safe LoRA (Ours) | 5.05 | 1.10 | $6.36 \%$ |

Table 2: The performance of Safe LoRA compared with LoRA, SafeInstr, and BEA methods under the Llama-2-7B-Chat/Llama-3-8B-Instruct models fine-tuned on the PureBad dataset.

Dialog Summary. We present a more practical fine-tuning scenario. We selected a dataset for a task that LLMs were originally not proficient in and required fine-tuning. Additionally, we assume that users might be malicious. Therefore, we augmented the Dialog Summary dataset with 100 harmful samples. We set the similarity score threshold at 0.35 , resulting in projections across 7 layers. As shown in Table 3, the Rouge-1 F1 score of the original Llama-2 model is only $34 \%$, but after fine-tuning, it can reach around $50 \%$. Adding SafeInstr to the training set does not harm utility, but it doesn't sufficiently reduce the harmfulness score. BEA also slightly reduces utility, but like SafeInstr, its performance on the harmfulness score is not as good as Safe LoRA. Safe LoRA's harmfulness score is at least 0.1 lower than theirs, and although its utility slightly decreases, it still approaches $50 \%$. However, one might be curious about whether Safe LoRA might harm the utility of datasets composed entirely of benign samples. We also apply Safe LoRA to the model trained exclusively on non-harmful samples with the same number of projected layers. The results indicate that Safe LoRA does not negatively impact the performance on the benign dataset, maintaining a Rouge-F1 score of approximately $50 \%$.

On the other hand, for Llama-3-8B-Instruct, we projected approximately $35 \%$ of the total LoRA layers. Since the alignment of Llama-3 is not as strong as that of Llama-2, the effectiveness of the alignment matrix is diminished. Thus, the number of projected layers is greater than for Llama-2. The utility of Safe LoRA can still achieve almost the same result as benign fine-tuning, at 49.04\%, while the harmfulness score decreases by around 0.4. SafeInstr gets the highest safety score, but its utility is reduced by $0.12 \%$. Conversely, BEA's utility is better than that of the originally fine-tuned model, but its alignment is also the lowest among the three. Besides, similar to the findings of Llama-2,
applying Safe LoRA to models trained without any malicious samples does not result in significant utility degradation.

| Models | Attack <br> (adversarial data) | Fine-tuned | Fine-tuning <br> Method | $\operatorname{Utility}(\uparrow)$ | Harmfulness <br> Score $(\downarrow)$ | $\operatorname{ASR}(\%)(\downarrow)$ |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| Llama-2-7B-Chat | $x$ | $x$ | None (original model) | $34 \%$ | 1.058 | $3.03 \%$ |
|  | $x$ | $\checkmark$ | LoRA | $49.57 \%$ | 1.27 | $9.70 \%$ |
|  | $\checkmark$ | $\checkmark$ | LoRA | $50.66 \%$ | 2.63 | $45.45 \%$ |
|  | $\checkmark$ | $\checkmark$ | SafeInstr | $\mathbf{5 0 . 2 1 \%}$ | 1.32 | $10.30 \%$ |
|  | $\checkmark$ | $\checkmark$ | BEA | $49.89 \%$ | 1.482 | $14.55 \%$ |
|  | $\checkmark$ | $\checkmark$ | Safe LoRA (Ours) | $49.79 \%$ | 1.297 | $8.79 \%$ |
|  | $x$ | $\checkmark$ | Safe LoRA (Ours) | $50.96 \%$ | 1.061 | $3.94 \%$ |
| Llama-3-8B-Instruct | $x$ | $x$ | None (original model) | $28.66 \%$ | 1.097 | $6.36 \%$ |
|  | $x$ | $\checkmark$ | LoRA | $49.04 \%$ | 1.16 | $7.27 \%$ |
|  | $\checkmark$ | $\checkmark$ | LoRA | $49.37 \%$ | 1.65 | $20.61 \%$ |
|  | $\checkmark$ | $\checkmark$ | SafeInstr | $48.92 \%$ | 1.236 | $8.48 \%$ |
|  | $\checkmark$ | $\checkmark$ | BEA | $49.97 \%$ | 1.288 | $10.91 \%$ |
|  | $\checkmark$ | $\checkmark$ | Safe LoRA (Ours) | $49.04 \%$ | 1.268 | $10.30 \%$ |
|  | $x$ | $\checkmark$ | Safe LoRA (Ours) | $47.64 \%$ | 1.15 | $6.97 \%$ |

Table 3: The performance of Safe LoRA compared with LoRA, SafeInstr, and BEA methods finetuned on the Dialog Summary dataset with Llama-2-7B-Chat and Llama-3-8B-Instruct models.

Alpaca Dataset. Interesting results demonstrated by [35] show that fine-tuning on a benign dataset can lead to a reduction in safety. We follow the same setting without adding more harmful samples. Here, we use MT-Bench scores as the evaluation metric (higher is better). Table 4 presents results consistent with [35], showing that the harmfulness score increased from 1.058 to 2.25. Although there is no harmful data in the Alpaca dataset, we still follow previous settings by adding safe instruction samples and backdoor samples for defense. SafeInstr and BEA did not perform well in this scenario due to the larger size of the Alpaca dataset. This highlights one of their drawbacks: they require a sufficient number of safe instructions or backdoor samples in the training set to perform effectively.

On the other hand, we have chosen not to present the results for Llama-3 because when using an appropriate learning rate, the ASR only increases by approximately $3 \%$, indicating that alignment is only minimally reduced. Although increasing the learning rate can effectively reduce safety, it also causes significant harm to the model's utility. This approach, therefore, is not suitable for typical user fine-tuning scenarios, as the trade-off between alignment and utility becomes unfavorable. In essence, while a higher learning rate might achieve lower safety scores, the resulting decrease in model utility renders this method impractical for regular use.

| Models | Fine-tuned | Fine-tuning Method | Utility( $\uparrow$ ) | Harmfulness <br> Score $(\downarrow)$ | ASR $(\%)(\downarrow)$ |
| :---: | :---: | :---: | :---: | :---: | :---: |
|  | $\boldsymbol{\checkmark}$ | LoRA | 5.06 | 2.25 | $86.67 \%$ |
|  | $\checkmark$ | SafeInstr | $\mathbf{5 . 6 4}$ | 2.04 | $80 \%$ |
|  | $\boldsymbol{V}$ | Safe LoRA (Ours) | 5.62 | $\mathbf{1 . 0 9}$ | $\mathbf{6 . 6 7 \%}$ |

Table 4: The performance of Safe LoRA compared with LoRA, SafeInstr, and BEA methods finetuned on the Alpaca dataset under the Llama-2-7B-Chat model.

### 4.2 Ablation Study

Utility v.s. Safety. In this paragraph, we show the trade-off between utility and harmfulness scores by varying the threshold of similarity score in Figure 3, which also corresponds to the number of projected layers. Furthermore, Figure 4 presents the similarity score between $\mathbf{C} \Delta \mathbf{W}$ and $\mathbf{A B}^{T}$ for all layers of LoRA. In Figures 3 and 4, we use the Llama-2-Chat model fine-tuned on the Dialog Summary dataset with the same settings as in Section 4.1. Figure 3 clearly demonstrates that projecting more layers tends to cause more harm to utility. At approximately $11 \%$ of the total layers projected, there exists a well-balanced point between utility and safety. Here, there is a loss of less than 2\% in Rouge F1-Score, while the harmfulness score decreases by more than 2. As shown in

![](https://cdn.mathpix.com/cropped/2024_05_29_27f2eee6eec91ae48213g-09.jpg?height=477&width=653&top_left_y=274&top_left_x=389)

Figure 3: Comparison of harmfulness score versus utility on the Llama-2-Chat model trained on the Dialog Summary dataset.

![](https://cdn.mathpix.com/cropped/2024_05_29_27f2eee6eec91ae48213g-09.jpg?height=477&width=591&top_left_y=274&top_left_x=1100)

Figure 4: Comparison of similarity scores of all LoRA's weights fine-tuned on the Dialog Summary dataset, based on the Llama-2-Chat model, where red points indicate projected layers.

Figure 4 , it can be observed that only a few layers display notably low similarity score, represented by the red points. Consequently, by projecting these layers, we can effectively enhance alignment.

Full Fine-tuning. In addition to LoRA fine-tuning, we perform full fine-tuning on the PureBad dataset following the same settings as in Section 4.1. The projection process is similar to fine-tuning with LoRA and is formalized as follows:

$$
\begin{equation*}
\mathbf{W}_{\text {fine-tuned }}^{i}=\mathbf{W}_{\text {pre-trained }}^{i}+\mathbf{C}^{i}\left(\mathbf{W}_{\text {fine-tuned }}^{i}-\mathbf{W}_{\text {pre-trained }}^{i}\right) \tag{4}
\end{equation*}
$$

where $\mathbf{W}_{\text {pre-trained }}^{i}$ and $\mathbf{W}_{\text {fine-tuned }}^{i}$ represent the weights of the pre-trained and fine-tuned models in the $i$-th layer, respectively. Instead of directly projecting the weights of the fine-tuned model, we project the residual weights between the pre-trained and fine-tuned models.

Table 5 demonstrates the performance of Safe LoRA when we perform full parameter fine-tuning on the PureBad dataset using the Llama-2-Chat model. All settings follow those in Section 4.1

Under the same settings, full parameter fine-tuning results in a greater decrease in alignment and utility, with a harmfulness score 0.1 higher and an MT-Bench score at least 0.2 lower compared to LoRA (as shown in Table 2). However, with the implementation of Safe LoRA, the harmfulness score dramatically drops to around 1.05. Furthermore, the MT-Bench score also increases to 6.4 , a rise of more than 2 .

|  | Harmfulness Score $(\downarrow)$ | MT-Bench $(1 \sim 10, \uparrow)$ | ASR $(\downarrow)$ |
| :---: | :---: | :---: | :---: |
| Native Full Fine-tuning | 4.71 | 4.325 | $95.45 \%$ |
| Safe LoRA | 1.05 | 6.401 | 3.03 |

Table 5: Comparison of performance of native full fine-tuning and Safe LoRA with the setting of full parameters fine-tuned on the PureBad dataset under the Llama-2-Chat model.

## 5 Conclusion

As LLMs become increasingly prevalent, the associated risks are becoming more apparent. Recent studies have demonstrated that fine-tuning can reduce safety alignment, causing LLMs to provide inappropriate responses. In this paper, we propose Safe LoRA to address the safety alignment issues caused by fine-tuning LLMs, without making any assumptions about the user's intentions, whether benign or malicious. Safe LoRA operates efficiently without requiring additional data or extra training. Overall, Safe LoRA effectively mitigates the safety concerns arising from fine-tuning LLMs while maintaining an acceptable level of utility.

Broader Impact and Limitations We believe that Safe LoRA presents potential in safeguarding the risk brought upon by various fine-tuning scenarios for LLMs. Unfortunately, the transparency of
this method may be subjected to future attacks as they might be able to circumvent this in an adaptive manner. On the other hand, given the increasing trend in model parameter manipulation and the upsurge in GenAI, we believe that Safe LoRA could also be applied to other multimodal models such as Text-to-Image Models to safeguard the alignment rules embedded in their systems.

## References

[1] Anthropic. Claude. https://claude.ai/. 2023a.

[2] Anthropic. Claude 2. https://www.anthropic.com/news/claude-2. 2023b.

[3] Amanda Askell, Yuntao Bai, Anna Chen, Dawn Drain, Deep Ganguli, Tom Henighan, Andy Jones, Nicholas Joseph, Ben Mann, Nova DasSarma, et al. A general language assistant as a laboratory for alignment. arXiv preprint arXiv:2112.00861, 2021.

[4] Yuntao Bai, Andy Jones, Kamal Ndousse, Amanda Askell, Anna Chen, Nova DasSarma, Dawn Drain, Stanislav Fort, Deep Ganguli, Tom Henighan, et al. Training a helpful and harmless assistant with reinforcement learning from human feedback. arXiv preprint arXiv:2204.05862, 2022.

[5] Yuntao Bai, Saurav Kadavath, Sandipan Kundu, Amanda Askell, Jackson Kernion, Andy Jones, Anna Chen, Anna Goldie, Azalia Mirhoseini, Cameron McKinnon, et al. Constitutional ai: Harmlessness from ai feedback. arXiv preprint arXiv:2212.08073, 2022.

[6] Federico Bianchi, Mirac Suzgun, Giuseppe Attanasio, Paul Rottger, Dan Jurafsky, Tatsunori Hashimoto, and James Zou. Safety-tuned LLaMAs: Lessons from improving the safety of large language models that follow instructions. In The Twelfth International Conference on Learning Representations (ICLR), 2024.

[7] Wei-Lin Chiang, Zhuohan Li, Zi Lin, Ying Sheng, Zhanghao Wu, Hao Zhang, Lianmin Zheng, Siyuan Zhuang, Yonghao Zhuang, Joseph E Gonzalez, et al. Vicuna: An open-source chatbot impressing gpt-4 with $90 \% *$ chatgpt quality. See https://vicuna. lmsys. org (accessed 14 April 2023), 2(3):6, 2023.

[8] Leshem Choshen, Elad Venezian, Noam Slonim, and Yoav Katz. Fusing finetuned models for better pretraining. arXiv preprint arXiv:2204.03044, 2022.

[9] Paul F Christiano, Jan Leike, Tom Brown, Miljan Martic, Shane Legg, and Dario Amodei. Deep reinforcement learning from human preferences. Advances in Neural Information Processing Systems (NeurIPS), 30, 2017.

[10] Ning Ding, Yulin Chen, Bokai Xu, Yujia Qin, Zhi Zheng, Shengding Hu, Zhiyuan Liu, Maosong Sun, and Bowen Zhou. Enhancing chat language models by scaling high-quality instructional conversations. In Conference on Empirical Methods in Natural Language Processing (EMNLP), 2023 .

[11] Timur Garipov, Pavel Izmailov, Dmitrii Podoprikhin, Dmitry P Vetrov, and Andrew G Wilson. Loss surfaces, mode connectivity, and fast ensembling of dnns. Advances in neural information processing systems, 31, 2018.

[12] Xinyang Geng, Arnav Gudibande, Hao Liu, Eric Wallace, Pieter Abbeel, Sergey Levine, and Dawn Song. Koala: A dialogue model for academic research. Blog post, April, 1:6, 2023.

[13] Mor Geva, Avi Caciularu, Guy Dar, Paul Roit, Shoval Sadde, Micah Shlain, Bar Tamir, and Yoav Goldberg. Lm-debugger: An interactive tool for inspection and intervention in transformerbased language models. In Conference on Empirical Methods in Natural Language Processing (EMNLP), 2022.

[14] Amelia Glaese, Nat McAleese, Maja Trębacz, John Aslanides, Vlad Firoiu, Timo Ewalds, Maribeth Rauh, Laura Weidinger, Martin Chadwick, Phoebe Thacker, et al. Improving alignment of dialogue agents via targeted human judgements. arXiv preprint arXiv:2209.14375, 2022.

[15] Bogdan Gliwa, Iwona Mochol, Maciej Biesek, and Aleksander Wawer. SAMSum corpus: A human-annotated dialogue dataset for abstractive summarization. In Proceedings of the 2nd Workshop on New Frontiers in Summarization, pages 70-79, Hong Kong, China, 2019. Association for Computational Linguistics.

[16] Edward J Hu, yelong shen, Phillip Wallis, Zeyuan Allen-Zhu, Yuanzhi Li, Shean Wang, Lu Wang, and Weizhu Chen. Lora: Low-rank adaptation of large language models. In International Conference on Learning Representations (ICLR), 2022.

[17] Zhiqiang Hu, Lei Wang, Yihuai Lan, Wanyu Xu, Ee-Peng Lim, Lidong Bing, Xing Xu, Soujanya Poria, and Roy Lee. LLM-adapters: An adapter family for parameter-efficient fine-tuning of large language models. In Houda Bouamor, Juan Pino, and Kalika Bali, editors, Conference on Empirical Methods in Natural Language Processing (EMNLP), 2023.

[18] Yangsibo Huang, Samyak Gupta, Mengzhou Xia, Kai Li, and Danqi Chen. Catastrophic jailbreak of open-source LLMs via exploiting generation. In The Twelfth International Conference on Learning Representations, 2024.

[19] Gabriel Ilharco, Marco Tulio Ribeiro, Mitchell Wortsman, Ludwig Schmidt, Hannaneh Hajishirzi, and Ali Farhadi. Editing models with task arithmetic. In The Eleventh International Conference on Learning Representations, 2023.

[20] Gabriel Ilharco, Mitchell Wortsman, Samir Yitzhak Gadre, Shuran Song, Hannaneh Hajishirzi, Simon Kornblith, Ali Farhadi, and Ludwig Schmidt. Patching open-vocabulary models by interpolating weights. Advances in Neural Information Processing Systems (NeurIPS), 35:2926229277,2022 .

[21] Atoosa Kasirzadeh and Iason Gabriel. In conversation with artificial intelligence: aligning language models with human values. Philosophy \& Technology, 36(2):27, 2023.

[22] Margaret Li, Suchin Gururangan, Tim Dettmers, Mike Lewis, Tim Althoff, Noah A Smith, and Luke Zettlemoyer. Branch-train-merge: Embarrassingly parallel training of expert language models. In NeurIPS Workshop on Interpolation and Beyond, 2022.

[23] Xiang Lisa Li and Percy Liang. Prefix-tuning: Optimizing continuous prompts for generation. In Chengqing Zong, Fei Xia, Wenjie Li, and Roberto Navigli, editors, Annual Meeting of the Association for Computational Linguistics (ACL), 2021.

[24] Xiaogeng Liu, Nan Xu, Muhao Chen, and Chaowei Xiao. Autodan: Generating stealthy jailbreak prompts on aligned large language models. In International Conference on Learning Representations (ICLR), 2024.

[25] Yi Liu, Gelei Deng, Zhengzi Xu, Yuekang Li, Yaowen Zheng, Ying Zhang, Lida Zhao, Tianwei Zhang, and Yang Liu. Jailbreaking chatgpt via prompt engineering: An empirical study. arXiv preprint arXiv:2305.13860, 2023.

[26] Michael S Matena and Colin A Raffel. Merging models with fisher-weighted averaging. Advances in Neural Information Processing Systems (NeurIPS), 35:17703-17716, 2022.

[27] Anay Mehrotra, Manolis Zampetakis, Paul Kassianik, Blaine Nelson, Hyrum Anderson, Yaron Singer, and Amin Karbasi. Tree of attacks: Jailbreaking black-box llms automatically. arXiv preprint arXiv:2312.02119, 2023.

[28] Meta. Llama 3. https://ai.meta.com/blog/meta-llama-3/. 2024.

[29] Eric Mitchell, Charles Lin, Antoine Bosselut, Chelsea Finn, and Christopher D Manning. Fast model editing at scale. In International Conference on Learning Representations (ICLR), 2022.

[30] Eric Mitchell, Charles Lin, Antoine Bosselut, Christopher D Manning, and Chelsea Finn. Memory-based model editing at scale. In International Conference on Machine Learning, pages 15817-15831. PMLR, 2022.

[31] Shikhar Murty, Christopher D Manning, Scott Lundberg, and Marco Tulio Ribeiro. Fixing model bugs with natural language patches. In Conference on Empirical Methods in Natural Language Processing (EMNLP), 2022.

[32] OpenAI. Gpt-4 technical report. arxiv 2303.08774. View in Article, 2(5), 2023.

[33] Long Ouyang, Jeffrey Wu, Xu Jiang, Diogo Almeida, Carroll Wainwright, Pamela Mishkin, Chong Zhang, Sandhini Agarwal, Katarina Slama, Alex Ray, et al. Training language models to follow instructions with human feedback. Advances in neural information processing systems (NeurIPS), 35:27730-27744, 2022.

[34] Xiangyu Qi, Kaixuan Huang, Ashwinee Panda, Peter Henderson, Mengdi Wang, and Prateek Mittal. Visual adversarial examples jailbreak aligned large language models. In Proceedings of the AAAI Conference on Artificial Intelligence, volume 38, pages 21527-21536, 2024.

[35] Xiangyu Qi, Yi Zeng, Tinghao Xie, Pin-Yu Chen, Ruoxi Jia, Prateek Mittal, and Peter Henderson. Fine-tuning aligned language models compromises safety, even when users do not intend to! In The Twelfth International Conference on Learning Representations (ICLR), 2024.

[36] Rafael Rafailov, Archit Sharma, Eric Mitchell, Christopher D Manning, Stefano Ermon, and Chelsea Finn. Direct preference optimization: Your language model is secretly a reward model. Advances in Neural Information Processing Systems (NeurIPS), 36, 2024.

[37] Marco Tulio Ribeiro and Scott Lundberg. Adaptive testing and debugging of nlp models. In Annual Meeting of the Association for Computational Linguistics (ACL), pages 3253-3267, 2022.

[38] Shibani Santurkar, Dimitris Tsipras, Mahalaxmi Elango, David Bau, Antonio Torralba, and Aleksander Madry. Editing a classifier by rewriting its prediction rules. Advances in Neural Information Processing Systems (NeurIPS), 34:23359-23373, 2021.

[39] Xinyue Shen, Zeyuan Chen, Michael Backes, Yun Shen, and Yang Zhang. "do anything now": Characterizing and evaluating in-the-wild jailbreak prompts on large language models. ACM Conference on Computer and Communications Security (CCS), 2024.

[40] Nishant Subramani, Nivedita Suresh, and Matthew E Peters. Extracting latent steering vectors from pretrained language models. In Findings of the Association for Computational Linguistics $(A C L), 2022$.

[41] Yi-Lin Sung, Varun Nair, and Colin A Raffel. Training neural networks with fixed sparse masks. Advances in Neural Information Processing Systems (NeurIPS), 34:24193-24205, 2021.

[42] Rohan Taori, Ishaan Gulrajani, Tianyi Zhang, Yann Dubois, Xuechen Li, Carlos Guestrin, Percy Liang, and Tatsunori B Hashimoto. Stanford alpaca: An instruction-following llama model, 2023.

[43] Hugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajjwal Bhargava, Shruti Bhosale, et al. Llama 2: Open foundation and fine-tuned chat models. arXiv preprint arXiv:2307.09288, 2023.

[44] Alex Turner, Lisa Thiergart, David Udell, Gavin Leech, Ulisse Mini, and Monte MacDiarmid. Activation addition: Steering language models without optimization. arXiv preprint arXiv:2308.10248, 2023.

[45] Jiongxiao Wang, Jiazhao Li, Yiquan Li, Xiangyu Qi, Muhao Chen, Junjie Hu, Yixuan Li, Bo Li, and Chaowei Xiao. Mitigating fine-tuning jailbreak attack with backdoor enhanced alignment. arXiv preprint arXiv:2402.14968, 2024.

[46] Alexander Wei, Nika Haghtalab, and Jacob Steinhardt. Jailbroken: How does llm safety training fail? Advances in Neural Information Processing Systems (NeurIPS), 36, 2024.

[47] Jason Wei, Maarten Bosma, Vincent Y Zhao, Kelvin Guu, Adams Wei Yu, Brian Lester, Nan Du, Andrew M Dai, and Quoc V Le. Finetuned language models are zero-shot learners. In International Conference on Learning Representations (ICLR), 2022.

[48] Mitchell Wortsman, Gabriel Ilharco, Samir Ya Gadre, Rebecca Roelofs, Raphael Gontijo-Lopes, Ari S Morcos, Hongseok Namkoong, Ali Farhadi, Yair Carmon, Simon Kornblith, et al. Model soups: averaging weights of multiple fine-tuned models improves accuracy without increasing inference time. In International conference on machine learning, pages 23965-23998. PMLR, 2022.

[49] Mitchell Wortsman, Gabriel Ilharco, Jong Wook Kim, Mike Li, Simon Kornblith, Rebecca Roelofs, Raphael Gontijo Lopes, Hannaneh Hajishirzi, Ali Farhadi, Hongseok Namkoong, et al. Robust fine-tuning of zero-shot models. In IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), pages 7959-7971, 2022.

[50] Can Xu, Qingfeng Sun, Kai Zheng, Xiubo Geng, Pu Zhao, Jiazhan Feng, Chongyang Tao, and Daxin Jiang. Wizardlm: Empowering large language models to follow complex instructions. In International Conference on Learning Representations (ICLR), 2024.

[51] Xianjun Yang, Xiao Wang, Qi Zhang, Linda Petzold, William Yang Wang, Xun Zhao, and Dahua Lin. Shadow alignment: The ease of subverting safely-aligned language models. arXiv preprint arXiv:2310.02949, 2023.

[52] Zheng-Xin Yong, Cristina Menghini, and Stephen H Bach. Low-resource languages jailbreak gpt-4. In NeurIPS Workshop on Socially Responsible Language Modelling Research (SoLaR), 2023.

[53] Weizhe Yuan, Richard Yuanzhe Pang, Kyunghyun Cho, Sainbayar Sukhbaatar, Jing Xu, and Jason Weston. Self-rewarding language models. arXiv preprint arXiv:2401.10020, 2024.

[54] Youliang Yuan, Wenxiang Jiao, Wenxuan Wang, Jen-tse Huang, Pinjia He, Shuming Shi, and Zhaopeng Tu. Gpt-4 is too smart to be safe: Stealthy chat with llms via cipher. In International Conference on Learning Representations (ICLR), 2024.

[55] Zheng Yuan, Hongyi Yuan, Chuanqi Tan, Wei Wang, Songfang Huang, and Fei Huang. Rrhf: Rank responses to align language models with human feedback without tears. In Advances in Neural Information Processing Systems (NeurIPS), 2023.

[56] Qiusi Zhan, Richard Fang, Rohan Bindu, Akul Gupta, Tatsunori Hashimoto, and Daniel Kang. Removing rlhf protections in gpt-4 via fine-tuning. arXiv preprint arXiv:2311.05553, 2023.

[57] Lianmin Zheng, Wei-Lin Chiang, Ying Sheng, Siyuan Zhuang, Zhanghao Wu, Yonghao Zhuang, Zi Lin, Zhuohan Li, Dacheng Li, Eric Xing, et al. Judging llm-as-a-judge with mt-bench and chatbot arena. Advances in Neural Information Processing Systems (NeurIPS), 36, 2024.

[58] Daniel M Ziegler, Nisan Stiennon, Jeffrey Wu, Tom B Brown, Alec Radford, Dario Amodei, Paul Christiano, and Geoffrey Irving. Fine-tuning language models from human preferences. arXiv preprint arXiv:1909.08593, 2019.

[59] Andy Zou, Zifan Wang, J Zico Kolter, and Matt Fredrikson. Universal and transferable adversarial attacks on aligned language models. arXiv preprint arXiv:2307.15043, 2023.
